# "Extend Claude Code" 심도 분석

이 문서는 Claude Code의 **확장 아키텍처**를 설명하는 핵심 가이드입니다. 6가지 확장 메커니즘이 에이전트 루프의 서로 다른 지점에 플러그인되는 방식을 다룹니다.

## 1. 핵심 아키텍처: 에이전트 루프와 확장 레이어

Claude Code는 "에이전트 루프"라는 핵심 사이클을 반복합니다: **사용자 입력 → 모델 추론 → 도구 호출 → 결과 확인 → 다음 행동 결정**. 이 문서에서 소개하는 6가지 확장 기능은 이 루프의 각기 다른 위치에 개입합니다:

| 위치 | 기능 | 개입 방식 |
|------|------|-----------|
| 루프 **시작 전** (컨텍스트) | CLAUDE.md | 매 세션 시작 시 자동 주입 |
| 루프 **안에서** (온디맨드) | Skills, MCP | 필요할 때 로드/호출 |
| 루프 **밖에서** (격리) | 서브에이전트 | 별도 루프에서 실행 후 요약 반환 |
| 루프 **외부** (결정론적) | 훅 | LLM 없이 셸 스크립트 실행 |
| **패키징** | 플러그인/마켓플레이스 | 위 기능들을 묶어서 배포 |

이 구조가 중요한 이유는, 각 기능이 **컨텍스트 소비량과 제어권의 트레이드오프**가 다르기 때문입니다.

## 2. 각 기능의 핵심 차이점

### CLAUDE.md — "상시 메모리"

- 매 요청마다 전체 내용이 컨텍스트에 포함되므로, 길어질수록 비용이 선형 증가
- 500줄 이하를 권장하는 이유: 컨텍스트 윈도우의 고정 비용이 됨
- 디렉토리 계층 구조를 따라 누적(additive)되므로, 하위 디렉토리에 더 구체적인 규칙 배치 가능

### Skills — "온디맨드 지식 + 워크플로"

- 가장 유연한 확장. 참조형(API 가이드)과 액션형(`/deploy`) 두 가지 패턴
- 핵심 설계: **세션 시작 시 설명만 로드** → Claude가 관련성 판단 → 필요 시 전체 로드
- `disable-model-invocation: true`로 설정하면 Claude에게 완전히 숨길 수 있어서 부수 효과가 있는 스킬에 안전

### 서브에이전트 — "격리된 작업자"

- 컨텍스트 윈도우 관리의 핵심 전략. 수십 개 파일을 읽어도 메인 세션에는 요약만 돌아옴
- 메인 세션의 스킬/대화 기록을 상속하지 않으므로, 필요한 스킬을 `skills:` 필드로 명시 필요
- **병렬 실행**이 가능하여 `/review` 같은 스킬에서 보안/성능/스타일 검사를 동시 수행

### MCP — "외부 세계와의 브릿지"

- 데이터베이스, Slack, 브라우저 등 외부 시스템과의 상호작용을 가능하게 하는 프로토콜
- 도구 정의가 세션 시작 시 로드되어 매 요청마다 컨텍스트 차지
- 주의점: **연결이 조용히 끊어질 수 있음** — 도구가 경고 없이 사라지는 잠재적 장애 포인트

### 훅 — "결정론적 자동화"

- LLM이 전혀 관여하지 않는 유일한 기능. 셸 스크립트로 실행
- 컨텍스트 비용 제로 (출력을 대화에 주입하지 않는 한)
- 사용 예: 파일 편집 후 ESLint 실행, 커밋 전 포맷팅 등

## 3. 컨텍스트 경제학 — 가장 중요한 설계 원칙

이 문서의 핵심 메시지는 **"컨텍스트는 유한한 자원"**이라는 것입니다.

- **고정 비용**: CLAUDE.md + MCP 도구 정의 (매 요청마다)
- **가변 비용**: 스킬 (사용 시에만 전체 로드)
- **격리 비용**: 서브에이전트 (메인 컨텍스트와 분리)
- **무비용**: 훅 (외부 실행)

컨텍스트가 과도하면 단순히 윈도우가 차는 것이 아니라 **노이즈가 증가**하여 Claude의 판단력이 떨어집니다. 스킬이 올바르게 트리거되지 않거나 규칙을 놓치는 현상이 발생할 수 있습니다.

## 4. 레이어링 규칙 — 충돌 해결 전략

동일한 기능이 여러 수준(사용자/프로젝트/관리/플러그인)에 존재할 때:

| 기능 | 충돌 해결 방식 |
|------|----------------|
| CLAUDE.md | **누적** — 모든 수준의 내용이 동시 적용, 충돌 시 더 구체적인 것이 우선 |
| Skills/서브에이전트 | **이름 기반 덮어쓰기** — 우선순위: 관리 > 사용자 > 프로젝트 |
| MCP | **이름 기반 덮어쓰기** — 로컬 > 프로젝트 > 사용자 |
| 훅 | **전부 병합** — 모든 소스의 훅이 매칭 이벤트에 실행 |

## 5. 실전 조합 패턴

문서에서 제시하는 4가지 패턴이 실전에서의 설계 방향을 보여줍니다:

- **스킬 + MCP**: MCP가 "무엇에 연결할지"를, 스킬이 "어떻게 사용할지"를 담당. 분리의 핵심은 연결(infrastructure)과 지식(knowledge)의 구분
- **스킬 + 서브에이전트**: 하나의 스킬이 여러 서브에이전트를 병렬로 생성. 코드 리뷰 같은 다면적 작업에 적합
- **CLAUDE.md + 스킬**: "항상 적용" vs "필요할 때만" 지식의 구분. CLAUDE.md가 비대해지는 것을 방지하는 핵심 전략
- **훅 + MCP**: 훅이 이벤트를 감지하고 MCP를 통해 외부 액션을 트리거. 알림/모니터링 자동화에 유용

## 6. 요약: 확장 기능 선택 의사결정

```
Claude가 항상 알아야 하는가?
  ├─ Yes → CLAUDE.md (500줄 이하)
  └─ No → 가끔 필요한 지식/워크플로인가?
       ├─ Yes → Skill
       └─ No → 외부 서비스 연결이 필요한가?
            ├─ Yes → MCP
            └─ No → 컨텍스트 격리/병렬 실행이 필요한가?
                 ├─ Yes → 서브에이전트
                 └─ No → LLM 없이 결정론적 자동화인가?
                      ├─ Yes → 훅
                      └─ No → 여러 기능 조합으로 해결
```

이 문서는 Claude Code를 단순한 AI 코딩 도구가 아니라, **확장 가능한 에이전트 플랫폼**으로 설계했음을 보여주는 아키텍처 가이드입니다. 컨텍스트 관리라는 제약 아래서 각 기능의 역할을 명확히 분리한 것이 핵심 설계 철학입니다.
