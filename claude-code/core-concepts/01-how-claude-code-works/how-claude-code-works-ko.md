# Claude Code 작동 방식

> 에이전틱 루프, 내장 도구, 그리고 Claude Code가 프로젝트와 상호작용하는 방식을 이해합니다.

Claude Code는 터미널에서 실행되는 에이전틱 어시스턴트입니다. 코딩에 뛰어나지만, 명령줄에서 할 수 있는 모든 작업을 도울 수 있습니다: 문서 작성, 빌드 실행, 파일 검색, 주제 조사 등.

이 가이드는 핵심 아키텍처, 내장 기능, 그리고 [Claude Code를 효과적으로 사용하는 팁](#claude-code를-효과적으로-사용하기)을 다룹니다. 단계별 안내는 [일반적인 워크플로우](/en/common-workflows)를 참조하세요. 스킬, MCP, 훅과 같은 확장 기능에 대해서는 [Claude Code 확장](/en/features-overview)을 참조하세요.

## 에이전틱 루프

Claude에게 작업을 맡기면, **컨텍스트 수집**, **행동 수행**, **결과 검증**의 세 단계를 거칩니다. 이 단계들은 서로 자연스럽게 연결됩니다. Claude는 코드를 이해하기 위해 파일을 검색하든, 변경을 위해 편집하든, 작업을 확인하기 위해 테스트를 실행하든 전 과정에서 도구를 사용합니다.

루프는 요청에 따라 적응합니다. 코드베이스에 대한 질문은 컨텍스트 수집만 필요할 수 있습니다. 버그 수정은 세 단계를 반복적으로 순환합니다. 리팩토링은 광범위한 검증이 필요할 수 있습니다. Claude는 이전 단계에서 학습한 내용을 바탕으로 각 단계에 무엇이 필요한지 결정하며, 수십 개의 행동을 연결하고 경로를 수정해 나갑니다.

여러분도 이 루프의 일부입니다. 언제든지 개입하여 Claude를 다른 방향으로 이끌거나, 추가 컨텍스트를 제공하거나, 다른 접근 방식을 시도하도록 요청할 수 있습니다. Claude는 자율적으로 작업하지만 여러분의 입력에 반응합니다.

에이전틱 루프는 두 가지 구성 요소로 구동됩니다: 추론하는 [모델](#모델)과 행동하는 [도구](#도구). Claude Code는 Claude를 감싸는 **에이전틱 하네스** 역할을 합니다: 언어 모델을 유능한 코딩 에이전트로 변환하는 도구, 컨텍스트 관리, 실행 환경을 제공합니다.

### 모델

Claude Code는 Claude 모델을 사용하여 코드를 이해하고 작업에 대해 추론합니다. Claude는 모든 언어의 코드를 읽고, 컴포넌트 간의 연결을 이해하고, 목표를 달성하기 위해 무엇을 변경해야 하는지 파악할 수 있습니다. 복잡한 작업의 경우, 작업을 단계별로 나누고 실행하며 학습한 내용을 바탕으로 조정합니다.

서로 다른 트레이드오프를 가진 [여러 모델](/en/model-config)을 사용할 수 있습니다. Sonnet은 대부분의 코딩 작업을 잘 처리합니다. Opus는 복잡한 아키텍처 결정에 더 강력한 추론을 제공합니다. 세션 중에 `/model`로 전환하거나 `claude --model <이름>`으로 시작할 수 있습니다.

이 가이드에서 "Claude가 선택한다" 또는 "Claude가 결정한다"라고 할 때, 그것은 모델이 추론하는 것입니다.

### 도구

도구는 Claude Code를 에이전틱하게 만드는 핵심입니다. 도구 없이 Claude는 텍스트로만 응답할 수 있습니다. 도구가 있으면 Claude는 행동할 수 있습니다: 코드를 읽고, 파일을 편집하고, 명령을 실행하고, 웹을 검색하고, 외부 서비스와 상호작용할 수 있습니다. 각 도구 사용은 루프에 다시 피드백되는 정보를 반환하여 Claude의 다음 결정에 영향을 줍니다.

내장 도구는 일반적으로 네 가지 범주로 나뉩니다. 각각 서로 다른 종류의 에이전시를 나타냅니다.

| 범주 | Claude가 할 수 있는 것 |
| --- | --- |
| **파일 작업** | 파일 읽기, 코드 편집, 새 파일 생성, 이름 변경 및 재구성 |
| **검색** | 패턴으로 파일 찾기, 정규식으로 내용 검색, 코드베이스 탐색 |
| **실행** | 셸 명령 실행, 서버 시작, 테스트 실행, git 사용 |
| **웹** | 웹 검색, 문서 가져오기, 오류 메시지 조회 |
| **코드 인텔리전스** | 편집 후 타입 오류 및 경고 확인, 정의로 이동, 참조 찾기 ([코드 인텔리전스 플러그인](/en/discover-plugins#code-intelligence) 필요) |

이것들이 주요 기능입니다. Claude에는 서브에이전트 생성, 질문하기 및 기타 오케스트레이션 작업을 위한 도구도 있습니다. 전체 목록은 [Claude에게 제공되는 도구](/en/settings#tools-available-to-claude)를 참조하세요.

Claude는 프롬프트와 과정에서 학습한 내용을 바탕으로 어떤 도구를 사용할지 선택합니다. "실패하는 테스트를 수정해줘"라고 말하면, Claude는 다음과 같이 할 수 있습니다:

1. 테스트 스위트를 실행하여 무엇이 실패하는지 확인
2. 오류 출력을 읽기
3. 관련 소스 파일 검색
4. 해당 파일을 읽어 코드 이해
5. 파일을 편집하여 문제 수정
6. 테스트를 다시 실행하여 검증

각 도구 사용은 Claude에게 다음 단계에 영향을 주는 새로운 정보를 제공합니다. 이것이 에이전틱 루프의 실제 동작입니다.

**기본 기능 확장:** 내장 도구는 기초입니다. [스킬](/en/skills)로 Claude가 아는 것을 확장하고, [MCP](/en/mcp)로 외부 서비스에 연결하고, [훅](/en/hooks)으로 워크플로우를 자동화하고, [서브에이전트](/en/sub-agents)로 작업을 위임할 수 있습니다. 이러한 확장은 핵심 에이전틱 루프 위에 구축되는 레이어를 형성합니다. 필요에 맞는 확장 선택에 대한 안내는 [Claude Code 확장](/en/features-overview)을 참조하세요.

## Claude가 접근할 수 있는 것

이 가이드는 터미널에 초점을 맞춥니다. Claude Code는 [VS Code, JetBrains IDE 및 기타 환경](/en/ide-integrations)에서도 실행됩니다.

디렉토리에서 `claude`를 실행하면, Claude Code는 다음에 접근할 수 있습니다:

* **프로젝트.** 디렉토리와 하위 디렉토리의 파일, 그리고 권한이 있는 다른 위치의 파일.
* **터미널.** 여러분이 실행할 수 있는 모든 명령: 빌드 도구, git, 패키지 매니저, 시스템 유틸리티, 스크립트. 명령줄에서 할 수 있다면, Claude도 할 수 있습니다.
* **git 상태.** 현재 브랜치, 커밋되지 않은 변경사항, 최근 커밋 히스토리.
* **[CLAUDE.md](/en/memory).** 프로젝트별 지침, 규칙, Claude가 매 세션마다 알아야 할 컨텍스트를 저장하는 마크다운 파일.
* **구성한 확장 기능.** 외부 서비스를 위한 [MCP 서버](/en/mcp), 워크플로우를 위한 [스킬](/en/skills), 위임 작업을 위한 [서브에이전트](/en/sub-agents), 브라우저 상호작용을 위한 [Chrome의 Claude](/en/chrome).

Claude는 전체 프로젝트를 볼 수 있기 때문에, 프로젝트 전체에 걸쳐 작업할 수 있습니다. Claude에게 "인증 버그를 수정해줘"라고 요청하면, 관련 파일을 검색하고, 컨텍스트를 이해하기 위해 여러 파일을 읽고, 그 파일들에 걸쳐 조율된 편집을 수행하고, 수정을 검증하기 위해 테스트를 실행하고, 요청하면 변경사항을 커밋합니다. 이것은 현재 파일만 볼 수 있는 인라인 코드 어시스턴트와 다릅니다.

## 세션 관리

Claude Code는 작업하면서 대화를 로컬에 저장합니다. 모든 메시지, 도구 사용, 결과가 저장되며, 이를 통해 [되감기](#체크포인트로-변경-취소), [재개 및 분기](#세션-재개-또는-분기)가 가능합니다. Claude가 코드를 변경하기 전에, 필요할 때 되돌릴 수 있도록 영향받는 파일의 스냅샷도 생성합니다.

**세션은 일시적입니다.** claude.ai와 달리, Claude Code는 세션 간에 영구 메모리가 없습니다. 새로운 세션은 처음부터 시작됩니다. Claude는 시간이 지남에 따라 선호도를 "학습"하거나 지난주에 작업한 내용을 기억하지 않습니다. 세션 간에 Claude가 알아야 할 것이 있다면 [CLAUDE.md](/en/memory)에 넣으세요.

### 브랜치 간 작업

각 Claude Code 대화는 현재 디렉토리에 연결된 세션입니다. 재개할 때, 해당 디렉토리의 세션만 볼 수 있습니다.

Claude는 현재 브랜치의 파일을 봅니다. 브랜치를 전환하면 Claude는 새 브랜치의 파일을 보지만, 대화 히스토리는 그대로 유지됩니다. Claude는 전환 후에도 논의한 내용을 기억합니다.

세션은 디렉토리에 연결되어 있으므로, [git worktrees](/en/common-workflows#run-parallel-claude-code-sessions-with-git-worktrees)를 사용하여 병렬 Claude 세션을 실행할 수 있습니다. git worktrees는 개별 브랜치를 위한 별도의 디렉토리를 생성합니다.

### 세션 재개 또는 분기

`claude --continue` 또는 `claude --resume`으로 세션을 재개하면, 동일한 세션 ID를 사용하여 중단했던 곳에서 계속합니다. 새 메시지는 기존 대화에 추가됩니다. 전체 대화 히스토리가 복원되지만, 세션 범위 권한은 복원되지 않습니다. 그것들은 다시 승인해야 합니다.

원래 세션에 영향을 주지 않고 다른 접근 방식을 시도하려면 `--fork-session` 플래그를 사용하세요:

```bash
claude --continue --fork-session
```

이렇게 하면 해당 시점까지의 대화 히스토리를 유지하면서 새 세션 ID가 생성됩니다. 원래 세션은 변경되지 않습니다. 재개와 마찬가지로, 분기된 세션은 세션 범위 권한을 상속하지 않습니다.

**여러 터미널에서 같은 세션**: 여러 터미널에서 같은 세션을 재개하면, 두 터미널 모두 같은 세션 파일에 기록합니다. 두 사람이 같은 노트북에 쓰는 것처럼 양쪽의 메시지가 섞입니다. 아무것도 손상되지 않지만, 대화가 뒤섞입니다. 각 터미널은 세션 중에 자신의 메시지만 보지만, 나중에 해당 세션을 재개하면 모든 것이 섞인 것을 볼 수 있습니다. 같은 시작점에서 병렬 작업을 하려면 `--fork-session`을 사용하여 각 터미널에 깨끗한 자체 세션을 제공하세요.

### 컨텍스트 윈도우

Claude의 컨텍스트 윈도우에는 대화 히스토리, 파일 내용, 명령 출력, [CLAUDE.md](/en/memory), 로드된 스킬, 시스템 지침이 포함됩니다. 작업하면서 컨텍스트가 채워집니다. Claude는 자동으로 압축하지만, 대화 초반의 지침이 손실될 수 있습니다. 지속적인 규칙은 CLAUDE.md에 넣고, `/context`를 실행하여 무엇이 공간을 사용하고 있는지 확인하세요.

#### 컨텍스트가 가득 찰 때

Claude Code는 한도에 가까워지면 자동으로 컨텍스트를 관리합니다. 먼저 오래된 도구 출력을 지우고, 필요하면 대화를 요약합니다. 요청과 핵심 코드 스니펫은 보존되지만, 대화 초반의 상세한 지침은 손실될 수 있습니다. 대화 히스토리에 의존하지 말고 지속적인 규칙은 CLAUDE.md에 넣으세요.

압축 시 보존되는 내용을 제어하려면, CLAUDE.md에 "Compact Instructions" 섹션을 추가하거나 `/compact`을 포커스와 함께 실행하세요 (예: `/compact focus on the API changes`).

`/context`를 실행하여 무엇이 공간을 사용하고 있는지 확인하세요. MCP 서버는 모든 요청에 도구 정의를 추가하므로, 몇 개의 서버만으로도 작업을 시작하기 전에 상당한 컨텍스트를 소비할 수 있습니다. `/mcp`를 실행하여 서버별 비용을 확인하세요.

#### 스킬과 서브에이전트로 컨텍스트 관리

압축 외에도, 컨텍스트에 로드되는 내용을 제어하기 위해 다른 기능을 사용할 수 있습니다.

[스킬](/en/skills)은 필요할 때 로드됩니다. Claude는 세션 시작 시 스킬 설명을 보지만, 전체 내용은 스킬이 사용될 때만 로드됩니다. 수동으로 호출하는 스킬의 경우, `disable-model-invocation: true`를 설정하면 필요할 때까지 설명이 컨텍스트에 포함되지 않습니다.

[서브에이전트](/en/sub-agents)는 메인 대화와 완전히 분리된 자체 컨텍스트를 가집니다. 그들의 작업은 여러분의 컨텍스트를 부풀리지 않습니다. 완료되면 요약을 반환합니다. 이 격리가 서브에이전트가 긴 세션에서 도움이 되는 이유입니다.

각 기능의 비용은 [컨텍스트 비용](/en/features-overview#understand-context-costs)을, 컨텍스트 관리 팁은 [토큰 사용량 줄이기](/en/costs#reduce-token-usage)를 참조하세요.

## 체크포인트와 권한으로 안전하게 사용하기

Claude에는 두 가지 안전 메커니즘이 있습니다: 체크포인트를 통해 파일 변경을 취소하고, 권한을 통해 Claude가 묻지 않고 할 수 있는 것을 제어합니다.

### 체크포인트로 변경 취소

**모든 파일 편집은 되돌릴 수 있습니다.** Claude가 파일을 편집하기 전에, 현재 내용의 스냅샷을 생성합니다. 문제가 발생하면, `Esc`를 두 번 눌러 이전 상태로 되돌리거나, Claude에게 취소를 요청하세요.

체크포인트는 세션에 로컬이며 git과 분리됩니다. 파일 변경만 다룹니다. 원격 시스템(데이터베이스, API, 배포)에 영향을 미치는 행동은 체크포인트할 수 없으며, 이것이 Claude가 외부 부작용이 있는 명령을 실행하기 전에 묻는 이유입니다.

### Claude가 할 수 있는 것 제어

`Shift+Tab`을 눌러 권한 모드를 순환하세요:

* **기본**: Claude가 파일 편집과 셸 명령 전에 묻습니다
* **편집 자동 승인**: Claude가 묻지 않고 파일을 편집하지만, 명령은 여전히 묻습니다
* **계획 모드**: Claude가 읽기 전용 도구만 사용하며, 실행 전에 승인할 수 있는 계획을 생성합니다

`.claude/settings.json`에서 특정 명령을 허용하여 Claude가 매번 묻지 않도록 할 수도 있습니다. 이것은 `npm test`나 `git status` 같은 신뢰할 수 있는 명령에 유용합니다. 설정은 조직 전체 정책에서 개인 선호도까지 범위를 지정할 수 있습니다. 자세한 내용은 [권한](/en/permissions)을 참조하세요.

---

## Claude Code를 효과적으로 사용하기

이 팁들은 Claude Code에서 더 나은 결과를 얻는 데 도움이 됩니다.

### Claude Code에게 도움 요청

Claude Code는 사용법을 가르쳐줄 수 있습니다. "훅을 어떻게 설정하나요?" 또는 "CLAUDE.md를 구조화하는 가장 좋은 방법은 무엇인가요?"와 같은 질문을 하면 Claude가 설명해줍니다.

내장 명령도 설정을 안내합니다:

* `/init`은 프로젝트를 위한 CLAUDE.md 생성을 안내합니다
* `/agents`는 커스텀 서브에이전트 구성을 도와줍니다
* `/doctor`는 설치의 일반적인 문제를 진단합니다

### 대화입니다

Claude Code는 대화형입니다. 완벽한 프롬프트가 필요 없습니다. 원하는 것으로 시작한 다음 다듬으세요:

```
> 로그인 버그를 수정해줘

[Claude가 조사하고, 시도함]

> 정확하지 않아. 문제는 세션 처리에 있어.

[Claude가 접근 방식을 조정함]
```

첫 시도가 맞지 않을 때, 처음부터 다시 시작할 필요 없습니다. 반복하면 됩니다.

#### 중단하고 방향 전환

언제든지 Claude를 중단할 수 있습니다. 잘못된 방향으로 가고 있다면, 수정 사항을 입력하고 Enter를 누르세요. Claude는 하던 것을 멈추고 입력에 따라 접근 방식을 조정합니다. 끝날 때까지 기다리거나 처음부터 다시 시작할 필요가 없습니다.

### 처음부터 구체적으로

초기 프롬프트가 정확할수록, 수정이 덜 필요합니다. 특정 파일을 참조하고, 제약 조건을 언급하고, 예제 패턴을 가리키세요.

```
> 만료된 카드를 가진 사용자의 결제 플로우가 깨져 있어.
> src/payments/에서 문제를 확인해줘, 특히 토큰 갱신.
> 먼저 실패하는 테스트를 작성하고, 그 다음 수정해줘.
```

"로그인 버그를 수정해줘" 같은 모호한 프롬프트도 동작하지만, 방향 전환에 더 많은 시간을 쓰게 됩니다. 위와 같은 구체적인 프롬프트는 종종 첫 시도에 성공합니다.

### Claude에게 검증할 수 있는 것을 제공

Claude는 자신의 작업을 확인할 수 있을 때 더 잘 수행합니다. 테스트 케이스를 포함하거나, 예상 UI의 스크린샷을 붙여넣거나, 원하는 출력을 정의하세요.

```
> validateEmail을 구현해줘. 테스트 케이스: 'user@example.com' → true,
> 'invalid' → false, 'user@.com' → false. 이후 테스트를 실행해줘.
```

시각적 작업의 경우, 디자인 스크린샷을 붙여넣고 Claude에게 구현과 비교하도록 요청하세요.

### 구현 전에 탐색

복잡한 문제의 경우, 조사와 코딩을 분리하세요. 계획 모드(`Shift+Tab` 두 번)를 사용하여 먼저 코드베이스를 분석하세요:

```
> src/auth/를 읽고 세션 처리 방식을 이해해줘.
> 그런 다음 OAuth 지원 추가 계획을 만들어줘.
```

계획을 검토하고, 대화를 통해 다듬은 다음, Claude에게 구현하게 하세요. 이 두 단계 접근 방식은 바로 코드로 뛰어드는 것보다 더 나은 결과를 만듭니다.

### 위임하기, 지시하지 않기

유능한 동료에게 위임한다고 생각하세요. 컨텍스트와 방향을 제공한 다음, Claude가 세부 사항을 파악하도록 하세요:

```
> 만료된 카드를 가진 사용자의 결제 플로우가 깨져 있어.
> 관련 코드는 src/payments/에 있어. 조사하고 수정해줄 수 있어?
```

어떤 파일을 읽을지, 어떤 명령을 실행할지 지정할 필요 없습니다. Claude가 스스로 파악합니다.

## 다음 단계

- [기능으로 확장](/en/features-overview): 스킬, MCP 연결, 커스텀 명령 추가
- [일반적인 워크플로우](/en/common-workflows): 일반적인 작업을 위한 단계별 가이드
