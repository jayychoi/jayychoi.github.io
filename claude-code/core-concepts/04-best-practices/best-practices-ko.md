# Claude Code 모범 사례

> 환경 설정부터 병렬 세션 확장까지, Claude Code를 최대한 활용하기 위한 팁과 패턴.

Claude Code는 에이전틱 코딩 환경입니다. 질문에 답하고 기다리는 챗봇과 달리, Claude Code는 파일을 읽고, 명령을 실행하고, 변경을 적용하며, 여러분이 지켜보거나, 방향을 수정하거나, 자리를 비운 사이에도 자율적으로 문제를 해결합니다.

이것은 작업 방식 자체를 바꿉니다. 직접 코드를 작성하고 Claude에게 리뷰를 요청하는 대신, 원하는 것을 설명하면 Claude가 어떻게 구현할지 알아냅니다. Claude가 탐색하고, 계획하고, 구현합니다.

하지만 이 자율성에는 여전히 학습 곡선이 있습니다. Claude는 여러분이 이해해야 할 특정 제약 조건 내에서 작동합니다.

이 가이드는 Anthropic 내부 팀과 다양한 코드베이스, 언어, 환경에서 Claude Code를 사용하는 엔지니어들 사이에서 효과적으로 입증된 패턴들을 다룹니다. 에이전틱 루프가 내부적으로 어떻게 작동하는지는 [Claude Code 작동 방식](/en/how-claude-code-works)을 참조하세요.

***

대부분의 모범 사례는 하나의 제약 조건에 기반합니다: Claude의 컨텍스트 윈도우는 빠르게 채워지며, 채워질수록 성능이 저하됩니다.

Claude의 컨텍스트 윈도우는 전체 대화를 보유합니다. 모든 메시지, Claude가 읽는 모든 파일, 모든 명령 출력이 포함됩니다. 하지만 이것은 빠르게 채워질 수 있습니다. 단일 디버깅 세션이나 코드베이스 탐색만으로도 수만 개의 토큰을 생성하고 소비할 수 있습니다.

이것이 중요한 이유는 컨텍스트가 채워질수록 LLM 성능이 저하되기 때문입니다. 컨텍스트 윈도우가 거의 차면 Claude가 이전 지시를 "잊어버리"거나 더 많은 실수를 할 수 있습니다. 컨텍스트 윈도우는 관리해야 할 가장 중요한 리소스입니다. 토큰 사용량을 줄이는 자세한 전략은 [토큰 사용량 줄이기](/en/costs#reduce-token-usage)를 참조하세요.

***

## Claude가 자신의 작업을 검증할 수 있는 방법을 제공하세요

> 테스트, 스크린샷, 또는 예상 출력을 포함시켜 Claude가 스스로 확인할 수 있게 하세요. 이것이 가장 효과가 높은 단일 행동입니다.

Claude는 자신의 작업을 검증할 수 있을 때 - 테스트 실행, 스크린샷 비교, 출력 검증 등 - 극적으로 더 나은 성능을 발휘합니다.

명확한 성공 기준이 없으면 겉보기에는 맞아 보이지만 실제로는 작동하지 않는 결과를 낼 수 있습니다. 여러분이 유일한 피드백 루프가 되고, 모든 실수는 여러분의 주의를 필요로 합니다.

| 전략 | 이전 | 이후 |
| --- | --- | --- |
| **검증 기준 제공** | *"이메일 주소를 검증하는 함수를 구현해"* | *"validateEmail 함수를 작성해. 예제 테스트 케이스: user@example.com은 true, invalid는 false, user@.com은 false. 구현 후 테스트를 실행해"* |
| **UI 변경을 시각적으로 검증** | *"대시보드를 더 보기 좋게 만들어"* | *"[스크린샷 붙여넣기] 이 디자인을 구현해. 결과의 스크린샷을 찍어서 원본과 비교해. 차이점을 나열하고 수정해"* |
| **증상이 아닌 근본 원인 해결** | *"빌드가 실패해"* | *"빌드가 이 에러로 실패해: [에러 붙여넣기]. 수정하고 빌드가 성공하는지 확인해. 에러를 억제하지 말고 근본 원인을 해결해"* |

UI 변경은 [Claude in Chrome 확장 프로그램](/en/chrome)을 사용하여 검증할 수 있습니다. 브라우저를 열고, UI를 테스트하며, 코드가 작동할 때까지 반복합니다.

검증은 테스트 스위트, 린터, 또는 출력을 확인하는 Bash 명령이 될 수도 있습니다. 검증을 견고하게 만드는 데 투자하세요.

***

## 먼저 탐색하고, 계획하고, 그다음 코딩하세요

> 조사와 계획을 구현과 분리하여 잘못된 문제를 해결하는 것을 방지하세요.

Claude가 바로 코딩에 뛰어들게 하면 잘못된 문제를 해결하는 코드를 만들 수 있습니다. [플랜 모드](/en/common-workflows#use-plan-mode-for-safe-code-analysis)를 사용하여 탐색과 실행을 분리하세요.

권장 워크플로우는 네 단계로 구성됩니다:

### 1단계: 탐색
플랜 모드로 진입합니다. Claude는 파일을 읽고 변경 없이 질문에 답합니다.

```
claude (플랜 모드)
/src/auth를 읽고 세션과 로그인을 어떻게 처리하는지 파악해.
시크릿을 위한 환경 변수 관리 방법도 살펴봐.
```

### 2단계: 계획
Claude에게 상세한 구현 계획을 생성하도록 요청합니다.

```
claude (플랜 모드)
Google OAuth를 추가하려고 해. 어떤 파일을 변경해야 해?
세션 흐름은 어떻게 돼? 계획을 세워줘.
```

`Ctrl+G`를 눌러 Claude가 진행하기 전에 텍스트 에디터에서 계획을 직접 편집할 수 있습니다.

### 3단계: 구현
일반 모드로 돌아가서 Claude가 계획에 따라 코딩하고 검증하도록 합니다.

```
claude (일반 모드)
계획에 따라 OAuth 흐름을 구현해. 콜백 핸들러에 대한
테스트를 작성하고, 테스트 스위트를 실행해서 실패가 있으면 수정해.
```

### 4단계: 커밋
Claude에게 설명적인 메시지로 커밋하고 PR을 생성하도록 요청합니다.

```
claude (일반 모드)
설명적인 메시지로 커밋하고 PR을 열어줘
```

> 플랜 모드는 유용하지만 오버헤드도 추가합니다.
>
> 범위가 명확하고 수정이 작은 작업(오타 수정, 로그 줄 추가, 변수 이름 변경 등)은 Claude에게 직접 하도록 요청하세요.
>
> 계획은 접근 방식이 불확실하거나, 변경이 여러 파일을 수정하거나, 수정할 코드에 익숙하지 않을 때 가장 유용합니다. diff를 한 문장으로 설명할 수 있다면 계획을 건너뛰세요.

***

## 프롬프트에 구체적인 컨텍스트를 제공하세요

> 지시가 정확할수록 수정 횟수가 줄어듭니다.

Claude는 의도를 추론할 수 있지만 마음을 읽지는 못합니다. 특정 파일을 참조하고, 제약 조건을 언급하고, 예제 패턴을 가리키세요.

| 전략 | 이전 | 이후 |
| --- | --- | --- |
| **작업 범위 지정.** 어떤 파일, 어떤 시나리오, 테스트 선호도를 지정합니다. | *"foo.py에 테스트 추가해"* | *"사용자가 로그아웃된 엣지 케이스를 다루는 foo.py 테스트를 작성해. 목(mock)은 피해."* |
| **출처를 가리키기.** Claude를 질문에 답할 수 있는 소스로 안내합니다. | *"ExecutionFactory가 왜 이렇게 이상한 API를 가지고 있어?"* | *"ExecutionFactory의 git 히스토리를 살펴보고 API가 어떻게 현재 형태가 되었는지 요약해"* |
| **기존 패턴 참조.** 코드베이스의 패턴을 Claude에게 가리킵니다. | *"캘린더 위젯 추가해"* | *"홈 페이지의 기존 위젯이 어떻게 구현되어 있는지 살펴서 패턴을 파악해. HotDogWidget.php가 좋은 예시야. 그 패턴을 따라서 사용자가 월을 선택하고 앞뒤로 페이지를 넘겨 연도를 선택할 수 있는 새 캘린더 위젯을 구현해. 코드베이스에 이미 사용된 라이브러리 외에는 사용하지 말고 처음부터 만들어."* |
| **증상 설명.** 증상, 가능한 위치, "수정됨"이 무엇인지를 제공합니다. | *"로그인 버그 수정해"* | *"사용자들이 세션 타임아웃 후 로그인이 실패한다고 보고해. src/auth/의 인증 흐름을, 특히 토큰 갱신을 확인해. 문제를 재현하는 실패하는 테스트를 작성하고 수정해"* |

모호한 프롬프트는 탐색 중이고 방향 수정이 가능할 때 유용할 수 있습니다. `"이 파일에서 무엇을 개선하겠어?"`와 같은 프롬프트는 여러분이 물어볼 생각도 못했던 것들을 발견할 수 있습니다.

### 풍부한 콘텐츠 제공

> `@`를 사용하여 파일을 참조하거나, 스크린샷/이미지를 붙여넣거나, 데이터를 직접 파이핑하세요.

Claude에게 풍부한 데이터를 여러 방법으로 제공할 수 있습니다:

* **`@`로 파일 참조** - 코드 위치를 설명하는 대신 사용. Claude가 응답 전에 파일을 읽습니다.
* **이미지 직접 붙여넣기**. 복사/붙여넣기 또는 드래그 앤 드롭으로 이미지를 프롬프트에 넣으세요.
* **URL 제공** - 문서와 API 참조용. `/permissions`를 사용하여 자주 사용하는 도메인을 허용 목록에 추가하세요.
* **데이터 파이핑** - `cat error.log | claude`를 실행하여 파일 내용을 직접 보내세요.
* **Claude가 필요한 것을 가져오게 하기**. Bash 명령, MCP 도구, 또는 파일 읽기를 통해 Claude가 직접 컨텍스트를 가져오도록 하세요.

***

## 환경 설정하기

몇 가지 설정 단계만으로 모든 세션에서 Claude Code의 효과가 크게 향상됩니다. 확장 기능의 전체 개요와 각각의 사용 시기는 [Claude Code 확장하기](/en/features-overview)를 참조하세요.

### 효과적인 CLAUDE.md 작성하기

> `/init`을 실행하여 현재 프로젝트 구조를 기반으로 초기 CLAUDE.md 파일을 생성한 다음, 시간이 지나면서 다듬어가세요.

CLAUDE.md는 Claude가 모든 대화의 시작 시 읽는 특별한 파일입니다. Bash 명령, 코드 스타일, 워크플로우 규칙을 포함하세요. 이것은 **코드만으로는 추론할 수 없는** 지속적인 컨텍스트를 Claude에게 제공합니다.

`/init` 명령은 빌드 시스템, 테스트 프레임워크, 코드 패턴을 감지하기 위해 코드베이스를 분석하여, 다듬을 수 있는 견고한 기반을 제공합니다.

CLAUDE.md 파일에 정해진 형식은 없지만, 짧고 읽기 쉽게 유지하세요. 예를 들어:

```markdown
# 코드 스타일
- ES 모듈(import/export) 구문 사용, CommonJS(require) 사용 금지
- 가능하면 임포트를 구조 분해 (예: import { foo } from 'bar')

# 워크플로우
- 일련의 코드 변경을 마치면 반드시 타입 체크 수행
- 성능을 위해 전체 테스트 스위트가 아닌 단일 테스트 실행 선호
```

CLAUDE.md는 매 세션마다 로드되므로, 광범위하게 적용되는 것만 포함하세요. 가끔만 관련되는 도메인 지식이나 워크플로우의 경우, 대신 [스킬](/en/skills)을 사용하세요. Claude가 필요할 때 로드하여 모든 대화를 비대하게 만들지 않습니다.

간결하게 유지하세요. 각 줄에 대해 물어보세요: *"이것을 제거하면 Claude가 실수를 할까?"* 그렇지 않다면 삭제하세요. 비대한 CLAUDE.md 파일은 Claude가 실제 지시를 무시하게 만듭니다!

| ✅ 포함할 것 | ❌ 제외할 것 |
| --- | --- |
| Claude가 추측할 수 없는 Bash 명령 | Claude가 코드를 읽어서 알 수 있는 것 |
| 기본값과 다른 코드 스타일 규칙 | Claude가 이미 아는 표준 언어 규약 |
| 테스트 지침 및 선호하는 테스트 러너 | 상세한 API 문서 (대신 문서로 링크) |
| 저장소 에티켓 (브랜치 네이밍, PR 규약) | 자주 변경되는 정보 |
| 프로젝트에 특정한 아키텍처 결정 | 긴 설명이나 튜토리얼 |
| 개발자 환경 특이사항 (필수 환경 변수) | 코드베이스의 파일별 설명 |
| 일반적인 함정이나 명확하지 않은 동작 | "깔끔한 코드를 작성하라" 같은 자명한 사항 |

규칙이 있음에도 Claude가 원하지 않는 행동을 계속한다면, 파일이 너무 길어서 규칙이 묻히고 있는 것일 수 있습니다. Claude가 CLAUDE.md에서 답할 수 있는 질문을 한다면, 표현이 모호할 수 있습니다. CLAUDE.md를 코드처럼 다루세요: 문제가 발생하면 검토하고, 정기적으로 정리하고, Claude의 동작이 실제로 변하는지 관찰하여 변경 사항을 테스트하세요.

강조(예: "IMPORTANT" 또는 "YOU MUST")를 추가하여 준수도를 높일 수 있습니다. CLAUDE.md를 git에 체크인하여 팀이 기여할 수 있게 하세요. 이 파일은 시간이 지날수록 가치가 복리로 증가합니다.

CLAUDE.md 파일은 `@path/to/import` 구문을 사용하여 추가 파일을 가져올 수 있습니다:

```markdown
프로젝트 개요는 @README.md를, 사용 가능한 npm 명령은 @package.json을 참조하세요.

# 추가 지침
- Git 워크플로우: @docs/git-instructions.md
- 개인 오버라이드: @~/.claude/my-project-instructions.md
```

CLAUDE.md 파일을 여러 위치에 배치할 수 있습니다:

* **홈 폴더 (`~/.claude/CLAUDE.md`)**: 모든 Claude 세션에 적용
* **프로젝트 루트 (`./CLAUDE.md`)**: git에 체크인하여 팀과 공유하거나, `CLAUDE.local.md`로 이름 짓고 `.gitignore`에 추가
* **상위 디렉토리**: `root/CLAUDE.md`와 `root/foo/CLAUDE.md` 모두 자동으로 가져오는 모노레포에 유용
* **하위 디렉토리**: Claude가 해당 디렉토리의 파일로 작업할 때 하위 CLAUDE.md 파일을 필요에 따라 가져옴

### 권한 설정하기

> `/permissions`를 사용하여 안전한 명령을 허용 목록에 추가하거나, `/sandbox`로 OS 수준 격리를 설정하세요. 이렇게 하면 통제권을 유지하면서 중단을 줄일 수 있습니다.

기본적으로 Claude Code는 시스템을 수정할 수 있는 작업(파일 쓰기, Bash 명령, MCP 도구 등)에 대해 권한을 요청합니다. 이것은 안전하지만 지루합니다. 열 번째 승인 후에는 실제로 검토하는 것이 아니라 그냥 클릭하는 것뿐입니다. 이러한 중단을 줄이는 두 가지 방법이 있습니다:

* **권한 허용 목록**: 안전하다고 알고 있는 특정 도구를 허용 (예: `npm run lint` 또는 `git commit`)
* **샌드박싱**: 파일 시스템과 네트워크 접근을 제한하는 OS 수준 격리를 활성화하여, Claude가 정의된 경계 내에서 더 자유롭게 작업할 수 있게 함

또는 린트 오류 수정이나 보일러플레이트 생성 같은 제한된 워크플로우에 `--dangerously-skip-permissions`를 사용하여 모든 권한 검사를 우회할 수 있습니다.

> Claude가 임의의 명령을 실행하면 데이터 손실, 시스템 손상, 또는 프롬프트 인젝션을 통한 데이터 유출이 발생할 수 있습니다. `--dangerously-skip-permissions`는 인터넷 접근이 없는 샌드박스에서만 사용하세요.

[권한 설정](/en/settings) 및 [샌드박싱 활성화](/en/sandboxing#sandboxing)에 대해 자세히 알아보세요.

### CLI 도구 사용하기

> 외부 서비스와 상호작용할 때 Claude Code에게 `gh`, `aws`, `gcloud`, `sentry-cli` 같은 CLI 도구를 사용하도록 지시하세요.

CLI 도구는 외부 서비스와 상호작용하는 가장 컨텍스트 효율적인 방법입니다. GitHub을 사용한다면 `gh` CLI를 설치하세요. Claude는 이슈 생성, 풀 리퀘스트 열기, 코멘트 읽기에 사용하는 방법을 알고 있습니다. `gh` 없이도 Claude는 GitHub API를 사용할 수 있지만, 인증되지 않은 요청은 종종 속도 제한에 걸립니다.

Claude는 아직 모르는 CLI 도구를 학습하는 데도 능숙합니다. `'foo-cli-tool --help'를 사용하여 foo 도구에 대해 배우고, 이를 사용하여 A, B, C를 해결해` 같은 프롬프트를 시도해보세요.

### MCP 서버 연결하기

> `claude mcp add`를 실행하여 Notion, Figma, 또는 데이터베이스 같은 외부 도구를 연결하세요.

[MCP 서버](/en/mcp)를 사용하면 Claude에게 이슈 트래커에서 기능 구현, 데이터베이스 쿼리, 모니터링 데이터 분석, Figma 디자인 통합, 워크플로우 자동화를 요청할 수 있습니다.

### 훅 설정하기

> 예외 없이 매번 발생해야 하는 작업에는 훅을 사용하세요.

[훅](/en/hooks-guide)은 Claude 워크플로우의 특정 지점에서 자동으로 스크립트를 실행합니다. 권고 사항인 CLAUDE.md 지침과 달리, 훅은 결정론적이며 작업이 반드시 발생하도록 보장합니다.

Claude가 훅을 작성해줄 수 있습니다. *"모든 파일 편집 후 eslint를 실행하는 훅을 작성해"* 또는 *"migrations 폴더에 쓰기를 차단하는 훅을 작성해"*와 같은 프롬프트를 시도하세요. `/hooks`를 실행하여 대화형 설정을 하거나, `.claude/settings.json`을 직접 편집하세요.

### 스킬 만들기

> `.claude/skills/`에 `SKILL.md` 파일을 생성하여 Claude에게 도메인 지식과 재사용 가능한 워크플로우를 제공하세요.

[스킬](/en/skills)은 프로젝트, 팀, 또는 도메인에 특정한 정보로 Claude의 지식을 확장합니다. Claude가 관련이 있을 때 자동으로 적용하거나, `/skill-name`으로 직접 호출할 수 있습니다.

`.claude/skills/`에 `SKILL.md`가 있는 디렉토리를 추가하여 스킬을 생성합니다:

```markdown
# .claude/skills/api-conventions/SKILL.md
---
name: api-conventions
description: 서비스를 위한 REST API 설계 규약
---
# API 규약
- URL 경로에 kebab-case 사용
- JSON 속성에 camelCase 사용
- 리스트 엔드포인트에는 항상 페이지네이션 포함
- URL 경로에서 API 버전 지정 (/v1/, /v2/)
```

직접 호출하는 반복 가능한 워크플로우도 정의할 수 있습니다:

```markdown
# .claude/skills/fix-issue/SKILL.md
---
name: fix-issue
description: GitHub 이슈 수정
disable-model-invocation: true
---
GitHub 이슈를 분석하고 수정합니다: $ARGUMENTS.

1. `gh issue view`로 이슈 상세 정보 확인
2. 이슈에 설명된 문제 이해
3. 관련 파일을 코드베이스에서 검색
4. 이슈를 수정하기 위한 필요한 변경 구현
5. 수정을 검증하기 위한 테스트 작성 및 실행
6. 코드가 린팅과 타입 체크를 통과하는지 확인
7. 설명적인 커밋 메시지 작성
8. 푸시 및 PR 생성
```

`/fix-issue 1234`로 호출합니다. 수동으로 트리거하려는 부작용이 있는 워크플로우에는 `disable-model-invocation: true`를 사용하세요.

### 커스텀 서브에이전트 만들기

> `.claude/agents/`에 전문화된 어시스턴트를 정의하여 Claude가 격리된 작업에 위임할 수 있게 하세요.

[서브에이전트](/en/sub-agents)는 자체 컨텍스트와 자체 허용 도구 세트로 실행됩니다. 많은 파일을 읽거나 메인 대화를 어지럽히지 않고 전문적인 집중이 필요한 작업에 유용합니다.

```markdown
# .claude/agents/security-reviewer.md
---
name: security-reviewer
description: 보안 취약점에 대한 코드 리뷰
tools: Read, Grep, Glob, Bash
model: opus
---
당신은 시니어 보안 엔지니어입니다. 코드를 다음 항목에 대해 리뷰하세요:
- 인젝션 취약점 (SQL, XSS, 커맨드 인젝션)
- 인증 및 권한 부여 결함
- 코드 내 시크릿 또는 자격 증명
- 안전하지 않은 데이터 처리

구체적인 줄 참조와 제안된 수정 사항을 제공하세요.
```

Claude에게 서브에이전트를 명시적으로 사용하도록 지시하세요: *"서브에이전트를 사용하여 이 코드의 보안 문제를 리뷰해."*

### 플러그인 설치하기

> `/plugin`을 실행하여 마켓플레이스를 탐색하세요. 플러그인은 설정 없이 스킬, 도구, 통합을 추가합니다.

[플러그인](/en/plugins)은 커뮤니티와 Anthropic의 스킬, 훅, 서브에이전트, MCP 서버를 단일 설치 가능한 단위로 묶습니다. 타입이 있는 언어를 사용한다면, [코드 인텔리전스 플러그인](/en/discover-plugins#code-intelligence)을 설치하여 Claude에게 정확한 심볼 탐색과 편집 후 자동 오류 감지를 제공하세요.

스킬, 서브에이전트, 훅, MCP 사이에서 선택하는 방법은 [Claude Code 확장하기](/en/features-overview#match-features-to-your-goal)를 참조하세요.

***

## 효과적으로 소통하기

Claude Code와 소통하는 방식이 결과의 품질에 크게 영향을 미칩니다.

### 코드베이스 질문하기

> 시니어 엔지니어에게 물어볼 질문을 Claude에게 하세요.

새로운 코드베이스에 온보딩할 때, 학습과 탐색을 위해 Claude Code를 사용하세요. 다른 엔지니어에게 물어볼 같은 종류의 질문을 Claude에게 할 수 있습니다:

* 로깅은 어떻게 작동해?
* 새 API 엔드포인트는 어떻게 만들어?
* `foo.rs`의 134번 줄에서 `async move { ... }`는 무엇을 해?
* `CustomerOnboardingFlowImpl`은 어떤 엣지 케이스를 처리해?
* 이 코드가 333번 줄에서 왜 `bar()` 대신 `foo()`를 호출해?

이런 식으로 Claude Code를 사용하는 것은 효과적인 온보딩 워크플로우로, 적응 시간을 단축하고 다른 엔지니어들의 부담을 줄입니다. 특별한 프롬프팅이 필요 없습니다: 직접 질문하세요.

### Claude가 인터뷰하게 하기

> 더 큰 기능의 경우, Claude에게 먼저 인터뷰하게 하세요. 최소한의 프롬프트로 시작하고 Claude에게 `AskUserQuestion` 도구를 사용하여 인터뷰하도록 요청하세요.

Claude는 기술 구현, UI/UX, 엣지 케이스, 트레이드오프 등 아직 고려하지 못한 것들에 대해 질문합니다.

```
[간략한 설명]을 만들고 싶어. AskUserQuestion 도구를 사용하여 자세히 인터뷰해.

기술 구현, UI/UX, 엣지 케이스, 우려 사항, 트레이드오프에 대해 물어봐.
뻔한 질문은 하지 말고, 내가 고려하지 못했을 어려운 부분을 파고들어.

모든 것을 다룰 때까지 인터뷰를 계속한 다음, 완전한 스펙을 SPEC.md에 작성해.
```

스펙이 완성되면, 새 세션을 시작하여 실행하세요. 새 세션은 구현에만 완전히 집중하는 깨끗한 컨텍스트를 갖고, 참조할 수 있는 서면 스펙이 있습니다.

***

## 세션 관리하기

대화는 지속적이고 되돌릴 수 있습니다. 이것을 활용하세요!

### 일찍 그리고 자주 방향 수정하기

> Claude가 잘못된 방향으로 가는 것을 발견하면 즉시 수정하세요.

최고의 결과는 빠른 피드백 루프에서 나옵니다. Claude가 가끔 첫 시도에 문제를 완벽히 해결하기도 하지만, 빠르게 수정하는 것이 일반적으로 더 나은 해결책을 더 빨리 만들어냅니다.

* **`Esc`**: `Esc` 키로 Claude의 작업을 중간에 중지. 컨텍스트가 보존되므로 방향을 수정할 수 있습니다.
* **`Esc + Esc` 또는 `/rewind`**: `Esc`를 두 번 누르거나 `/rewind`를 실행하여 되감기 메뉴를 열고 이전 대화 및 코드 상태를 복원.
* **`"되돌려"`**: Claude에게 변경 사항을 되돌리도록 지시.
* **`/clear`**: 관련 없는 작업 사이에 컨텍스트를 초기화. 관련 없는 컨텍스트가 있는 긴 세션은 성능을 저하시킬 수 있습니다.

한 세션에서 같은 문제로 Claude를 두 번 이상 수정했다면, 컨텍스트가 실패한 접근 방식들로 어지러워진 것입니다. `/clear`를 실행하고 배운 것을 반영한 더 구체적인 프롬프트로 새로 시작하세요. 더 나은 프롬프트가 있는 깨끗한 세션이 축적된 수정이 있는 긴 세션보다 거의 항상 더 나은 성능을 보입니다.

### 컨텍스트를 적극적으로 관리하기

> 관련 없는 작업 사이에 `/clear`를 실행하여 컨텍스트를 초기화하세요.

Claude Code는 컨텍스트 한계에 접근하면 자동으로 대화 기록을 압축하여, 중요한 코드와 결정을 보존하면서 공간을 확보합니다.

긴 세션 동안 Claude의 컨텍스트 윈도우는 관련 없는 대화, 파일 내용, 명령으로 채워질 수 있습니다. 이는 성능을 저하시키고 때로는 Claude의 주의를 분산시킵니다.

* 작업 사이에 `/clear`를 자주 사용하여 컨텍스트 윈도우를 완전히 초기화
* 자동 압축이 트리거되면, Claude는 코드 패턴, 파일 상태, 주요 결정 등 가장 중요한 것을 요약
* 더 많은 제어를 원하면 `/compact <지침>`을 실행, 예: `/compact API 변경에 집중해`
* CLAUDE.md에 `"압축할 때 수정된 파일의 전체 목록과 모든 테스트 명령을 항상 보존하라"` 같은 지침으로 압축 동작을 커스터마이즈하여 중요한 컨텍스트가 요약에서 살아남도록 보장

### 조사에 서브에이전트 사용하기

> `"서브에이전트를 사용하여 X를 조사해"`로 조사를 위임하세요. 별도 컨텍스트에서 탐색하여 메인 대화를 구현에 집중할 수 있게 유지합니다.

컨텍스트가 근본적인 제약 조건이므로, 서브에이전트는 사용 가능한 가장 강력한 도구 중 하나입니다. Claude가 코드베이스를 조사할 때 많은 파일을 읽으며, 이 모든 것이 컨텍스트를 소비합니다. 서브에이전트는 별도의 컨텍스트 윈도우에서 실행되고 요약을 보고합니다:

```
서브에이전트를 사용하여 인증 시스템이 토큰 갱신을 어떻게 처리하는지,
재사용해야 할 기존 OAuth 유틸리티가 있는지 조사해.
```

서브에이전트가 코드베이스를 탐색하고, 관련 파일을 읽고, 결과를 보고합니다 - 모두 메인 대화를 어지럽히지 않고.

Claude가 무언가를 구현한 후 검증을 위해 서브에이전트를 사용할 수도 있습니다:

```
서브에이전트를 사용하여 이 코드의 엣지 케이스를 리뷰해
```

### 체크포인트로 되감기

> Claude가 수행하는 모든 작업은 체크포인트를 생성합니다. 대화, 코드, 또는 둘 다를 이전 체크포인트로 복원할 수 있습니다.

Claude는 변경 전에 자동으로 체크포인트를 만듭니다. `Escape`를 두 번 누르거나 `/rewind`를 실행하여 체크포인트 메뉴를 엽니다. 대화만 복원(코드 변경 유지), 코드만 복원(대화 유지), 또는 둘 다 복원할 수 있습니다.

모든 움직임을 신중하게 계획하는 대신, Claude에게 위험한 것을 시도하라고 할 수 있습니다. 작동하지 않으면 되감고 다른 접근 방식을 시도하세요. 체크포인트는 세션 간에 유지되므로, 터미널을 닫아도 나중에 되감을 수 있습니다.

> 체크포인트는 *Claude가* 만든 변경만 추적하며, 외부 프로세스는 추적하지 않습니다. 이것은 git의 대체품이 아닙니다.

### 대화 재개하기

> `claude --continue`를 실행하여 이어서 작업하거나, `--resume`으로 최근 세션 중에서 선택하세요.

Claude Code는 대화를 로컬에 저장합니다. 작업이 여러 세션에 걸쳐 있을 때 (기능을 시작하다가, 중단되고, 다음 날 돌아올 때) 컨텍스트를 다시 설명할 필요가 없습니다:

```bash
claude --continue    # 가장 최근 대화 재개
claude --resume      # 최근 대화에서 선택
```

`/rename`을 사용하여 세션에 설명적인 이름(`"oauth-migration"`, `"debugging-memory-leak"`)을 지정하여 나중에 찾을 수 있게 하세요. 세션을 브랜치처럼 다루세요. 다른 작업 흐름에 별도의 지속적인 컨텍스트를 가질 수 있습니다.

***

## 자동화 및 확장

하나의 Claude로 효과를 본 후, 병렬 세션, 헤드리스 모드, 팬아웃 패턴으로 출력을 배가시키세요.

지금까지는 한 사람, 하나의 Claude, 하나의 대화를 가정했습니다. 하지만 Claude Code는 수평으로 확장됩니다. 이 섹션의 기법은 더 많은 것을 달성하는 방법을 보여줍니다.

### 헤드리스 모드 실행하기

> CI, pre-commit 훅, 또는 스크립트에서 `claude -p "prompt"`를 사용하세요. 스트리밍 JSON 출력을 위해 `--output-format stream-json`을 추가하세요.

`claude -p "your prompt"`로 대화형 세션 없이 Claude를 헤드리스로 실행할 수 있습니다. 헤드리스 모드는 Claude를 CI 파이프라인, pre-commit 훅, 또는 자동화된 워크플로우에 통합하는 방법입니다. 출력 형식(일반 텍스트, JSON, 스트리밍 JSON)을 통해 결과를 프로그래밍 방식으로 파싱할 수 있습니다.

```bash
# 일회성 쿼리
claude -p "이 프로젝트가 무엇을 하는지 설명해"

# 스크립트용 구조화된 출력
claude -p "모든 API 엔드포인트를 나열해" --output-format json

# 실시간 처리를 위한 스트리밍
claude -p "이 로그 파일을 분석해" --output-format stream-json
```

### 여러 Claude 세션 실행하기

> 개발 속도를 높이거나, 격리된 실험을 하거나, 복잡한 워크플로우를 시작하기 위해 여러 Claude 세션을 병렬로 실행하세요.

병렬 세션을 실행하는 두 가지 주요 방법이 있습니다:

* [Claude Desktop](/en/desktop): 여러 로컬 세션을 시각적으로 관리. 각 세션은 자체 격리된 워크트리를 가짐.
* [웹의 Claude Code](/en/claude-code-on-the-web): Anthropic의 보안 클라우드 인프라에서 격리된 VM으로 실행.

작업 병렬화 외에도, 여러 세션은 품질 중심 워크플로우를 가능하게 합니다. 새로운 컨텍스트는 Claude가 방금 작성한 코드에 편향되지 않으므로 코드 리뷰를 개선합니다.

예를 들어, 작성자/리뷰어 패턴을 사용합니다:

| 세션 A (작성자) | 세션 B (리뷰어) |
| --- | --- |
| `API 엔드포인트에 대한 속도 제한기 구현해` | |
| | `@src/middleware/rateLimiter.ts의 속도 제한기 구현을 리뷰해. 엣지 케이스, 경쟁 조건, 기존 미들웨어 패턴과의 일관성을 찾아봐.` |
| `리뷰 피드백이야: [세션 B 출력]. 이 문제들을 해결해.` | |

비슷하게 테스트로도 할 수 있습니다: 한 Claude가 테스트를 작성하고, 다른 Claude가 테스트를 통과하는 코드를 작성합니다.

### 파일 전체에 팬아웃하기

> 각 작업에 대해 `claude -p`를 호출하는 루프를 작성하세요. 배치 작업의 권한 범위를 지정하기 위해 `--allowedTools`를 사용하세요.

대규모 마이그레이션이나 분석의 경우, 많은 병렬 Claude 호출에 작업을 분산할 수 있습니다:

### 1단계: 작업 목록 생성
Claude에게 마이그레이션이 필요한 모든 파일을 나열하게 합니다 (예: `마이그레이션이 필요한 2,000개의 Python 파일을 모두 나열해`)

### 2단계: 목록을 순회하는 스크립트 작성

```bash
for file in $(cat files.txt); do
  claude -p "$file을 React에서 Vue로 마이그레이션해. OK 또는 FAIL을 반환해." \
    --allowedTools "Edit,Bash(git commit *)"
done
```

### 3단계: 몇 개 파일로 테스트 후 대규모 실행
처음 2-3개 파일에서 잘못되는 것을 기반으로 프롬프트를 개선한 다음, 전체 세트에서 실행하세요. `--allowedTools` 플래그는 Claude가 할 수 있는 것을 제한하며, 무인 실행 시 중요합니다.

기존 데이터/처리 파이프라인에 Claude를 통합할 수도 있습니다:

```bash
claude -p "<your prompt>" --output-format json | your_command
```

개발 중에는 디버깅을 위해 `--verbose`를 사용하고, 프로덕션에서는 끄세요.

### 안전한 자율 모드

`claude --dangerously-skip-permissions`를 사용하여 모든 권한 검사를 우회하고 Claude가 중단 없이 작업하게 하세요. 린트 오류 수정이나 보일러플레이트 코드 생성 같은 워크플로우에 잘 작동합니다.

> Claude가 임의의 명령을 실행하는 것은 위험하며 데이터 손실, 시스템 손상, 또는 데이터 유출(예: 프롬프트 인젝션 공격을 통해)을 초래할 수 있습니다. 이러한 위험을 최소화하려면 인터넷 접근이 없는 컨테이너에서 `--dangerously-skip-permissions`를 사용하세요.
>
> 샌드박싱이 활성화(`/sandbox`)되면 더 나은 보안과 함께 비슷한 자율성을 얻을 수 있습니다. 샌드박스는 모든 검사를 우회하는 대신 사전에 경계를 정의합니다.

***

## 일반적인 실패 패턴 피하기

이것들은 흔한 실수입니다. 일찍 인식하면 시간을 절약할 수 있습니다:

* **뒤죽박죽 세션.** 한 작업으로 시작해서, 관련 없는 것을 Claude에게 물어보고, 다시 첫 번째 작업으로 돌아갑니다. 컨텍스트가 관련 없는 정보로 가득 찹니다.
  > **해결**: 관련 없는 작업 사이에 `/clear`.
* **반복 수정.** Claude가 잘못하면, 수정하고, 여전히 틀리면, 다시 수정합니다. 컨텍스트가 실패한 접근 방식들로 오염됩니다.
  > **해결**: 두 번의 실패한 수정 후, `/clear`를 실행하고 배운 것을 반영한 더 나은 초기 프롬프트를 작성.
* **과도하게 구체적인 CLAUDE.md.** CLAUDE.md가 너무 길면 중요한 규칙이 잡음에 묻혀 Claude가 절반을 무시합니다.
  > **해결**: 가차없이 정리. Claude가 이미 지시 없이도 올바르게 하는 것은 삭제하거나 훅으로 변환.
* **신뢰 후 검증 격차.** Claude가 엣지 케이스를 처리하지 않는 그럴듯해 보이는 구현을 만듭니다.
  > **해결**: 항상 검증(테스트, 스크립트, 스크린샷)을 제공. 검증할 수 없으면 배포하지 마세요.
* **무한 탐색.** 범위를 지정하지 않고 Claude에게 무언가를 "조사"하라고 요청합니다. Claude가 수백 개의 파일을 읽으며 컨텍스트를 채웁니다.
  > **해결**: 조사 범위를 좁히거나 서브에이전트를 사용하여 탐색이 메인 컨텍스트를 소비하지 않도록 함.

***

## 직관을 키우세요

이 가이드의 패턴은 고정된 것이 아닙니다. 일반적으로 잘 작동하는 출발점이지만, 모든 상황에 최적이지는 않을 수 있습니다.

때로는 하나의 복잡한 문제에 깊이 빠져 있고 기록이 가치 있기 때문에 컨텍스트가 쌓이도록 *해야* 합니다. 때로는 작업이 탐색적이기 때문에 계획을 건너뛰고 Claude가 알아내게 해야 합니다. 때로는 모호한 프롬프트가 정확히 맞습니다. 문제를 제한하기 전에 Claude가 어떻게 해석하는지 보고 싶기 때문입니다.

무엇이 효과적인지 주의를 기울이세요. Claude가 훌륭한 결과를 낼 때, 무엇을 했는지 주목하세요: 프롬프트 구조, 제공한 컨텍스트, 사용한 모드. Claude가 어려움을 겪을 때, 왜인지 물어보세요. 컨텍스트가 너무 시끄러웠나? 프롬프트가 너무 모호했나? 한 번에 처리하기에 작업이 너무 컸나?

시간이 지나면서 어떤 가이드도 담을 수 없는 직관을 키우게 됩니다. 언제 구체적이어야 하고 언제 개방적이어야 하는지, 언제 계획하고 언제 탐색해야 하는지, 언제 컨텍스트를 초기화하고 언제 쌓이도록 해야 하는지 알게 됩니다.

## 관련 리소스

* [Claude Code 작동 방식](/en/how-claude-code-works) - 에이전틱 루프, 도구, 컨텍스트 관리 이해
* [Claude Code 확장하기](/en/features-overview) - 스킬, 훅, MCP, 서브에이전트, 플러그인 선택
* [일반적인 워크플로우](/en/common-workflows) - 디버깅, 테스트, PR 등을 위한 단계별 레시피
* [CLAUDE.md](/en/memory) - 프로젝트 규약 및 지속적 컨텍스트 저장
