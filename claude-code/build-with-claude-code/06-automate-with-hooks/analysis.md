# Claude Code Hooks 심층 분석

## 1. 핵심 개념 요약

Claude Code Hooks는 AI 코딩 어시스턴트의 동작을 **결정론적으로 제어**하기 위한 이벤트 기반 자동화 시스템이다. LLM의 비결정적 특성에 의존하지 않고, 특정 시점에 반드시 실행되어야 하는 동작을 보장한다는 점이 핵심이다.

### 세 가지 훅 유형

| 유형 | 실행 방식 | 적합한 상황 |
|------|-----------|-------------|
| `command` | 셸 명령 직접 실행 | 포맷팅, 로깅, 파일 보호 등 규칙 기반 작업 |
| `prompt` | LLM 단일 턴 평가 | 입력 데이터만으로 판단 가능한 경우 (코드 리뷰, 완료 확인) |
| `agent` | LLM 멀티 턴 + 도구 사용 | 파일 검사, 테스트 실행 등 코드베이스 상태 확인이 필요한 경우 |

이 세 유형의 설계는 **규칙(command) -> 판단(prompt) -> 검증(agent)** 순서로 복잡도가 증가하며, 개발자가 상황에 맞는 적절한 수준의 자동화를 선택할 수 있게 한다.

---

## 2. 아키텍처 분석

### 이벤트 라이프사이클

```
SessionStart -> UserPromptSubmit -> PreToolUse -> [도구 실행] -> PostToolUse/PostToolUseFailure
                                                                         |
                                                                         v
                                                              Stop -> SessionEnd
```

주목할 점은 **PreToolUse에서만 동작을 차단할 수 있다**는 것이다. PostToolUse 시점에서는 이미 도구가 실행된 후이므로 되돌릴 수 없다. 이는 훅 설계 시 가장 중요한 제약 조건이다.

### 통신 프로토콜

훅은 Unix 철학을 따른다:
- **stdin**: JSON 형태의 이벤트 데이터
- **stdout**: Claude에 주입할 컨텍스트 또는 구조화된 JSON 응답
- **stderr**: 피드백 메시지 (exit 2일 때 Claude에게 전달)
- **exit code**: 동작 제어 (0=허용, 2=차단, 기타=허용+로그)

이 설계 덕분에 **어떤 프로그래밍 언어로든 훅을 작성**할 수 있다. Bash, Python, Node.js, Go 등 JSON을 파싱하고 종료 코드를 반환할 수 있는 모든 언어가 사용 가능하다.

---

## 3. 실전 활용 전략

### 3.1 개발 품질 게이트 구축

훅을 조합하면 Claude Code가 코드를 작성하는 전 과정에 품질 게이트를 설정할 수 있다:

```
[PreToolUse]  보호 파일 편집 차단, 위험 명령 차단
      |
[PostToolUse] 자동 포맷팅, 린트 실행
      |
[Stop]        테스트 통과 확인, 작업 완료 검증
```

**실용적인 조합 예시:**

1. **PreToolUse (command)**: `.env`, 락파일, 마이그레이션 파일 편집 차단
2. **PostToolUse (command)**: Prettier/ESLint 자동 실행
3. **Stop (agent)**: 유닛 테스트 전체 통과 확인 후에만 종료 허용

이 조합이 강력한 이유는, Claude가 코드를 작성할 때 **사람이 수동으로 하던 검증 단계를 자동화**하기 때문이다. 코드 리뷰에서 반복적으로 지적하는 사항(포맷팅, 보호 파일 수정, 테스트 누락)을 훅으로 처리하면 리뷰어의 부담이 크게 줄어든다.

### 3.2 팀 단위 규칙 강제

훅 저장 위치의 계층 구조를 활용한 팀 단위 전략:

| 계층 | 저장 위치 | 용도 |
|------|-----------|------|
| 조직 | 관리형 정책 설정 | 보안 규칙 (시크릿 파일 보호, 위험 명령 차단) |
| 프로젝트 | `.claude/settings.json` | 프로젝트 컨벤션 (포맷터, 린터, 테스트 명령) |
| 개인 | `~/.claude/settings.json` | 개인 알림, 로깅 등 편의 기능 |

`.claude/settings.json`을 레포에 커밋하면 팀원 모두가 동일한 규칙을 공유한다. 개인 커스터마이징은 `.claude/settings.local.json`(gitignore 처리됨)이나 글로벌 설정에 넣는다.

### 3.3 CI/CD 파이프라인 통합

비대화형 모드(`-p`)에서의 훅 활용:

- `PermissionRequest` 훅은 비대화형 모드에서 발동되지 않으므로, **CI 환경에서는 반드시 `PreToolUse` 훅**을 사용해야 한다
- `Stop` 훅의 `agent` 타입으로 CI에서 자동 검증 파이프라인 구축 가능
- `SessionStart` 훅으로 CI 환경 변수나 빌드 컨텍스트를 주입

### 3.4 컨텍스트 윈도우 관리

컴팩션(compaction)은 장시간 세션에서 필연적으로 발생하는데, 이때 중요한 정보가 손실될 수 있다.

**전략적 컨텍스트 재주입 패턴:**

```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "compact",
        "hooks": [
          {
            "type": "command",
            "command": "cat .claude/compact-context.md && git log --oneline -10 && echo '현재 작업: feature/auth-refactor 브랜치'"
          }
        ]
      }
    ]
  }
}
```

`.claude/compact-context.md` 파일에 프로젝트 규칙, 아키텍처 결정사항, 현재 스프린트 목표 등을 정리해두면 컴팩션 후에도 Claude가 맥락을 잃지 않는다. `git log`로 최근 커밋을 함께 주입하면 작업 흐름의 연속성도 유지된다.

### 3.5 보안 강화

훅은 보안 경계를 설정하는 데 효과적이다:

- **파일 보호**: `.env`, 시크릿 파일, 락파일 편집 차단
- **명령 차단**: `rm -rf`, `DROP TABLE`, `--force` 등 위험 명령 차단
- **MCP 도구 감사**: 외부 MCP 서버 호출을 로깅하여 추적 가능

특히 `PreToolUse`의 구조화된 JSON 출력에서 `"permissionDecision": "deny"` 대신 `"ask"`를 사용하면, 완전 차단이 아닌 **사용자 확인 후 진행** 패턴을 구현할 수 있다. 이는 보안과 유연성의 균형점이다.

---

## 4. 설계 시 주의사항

### 무한 루프 방지

`Stop` 훅은 가장 강력하지만 가장 위험하다. Claude가 응답을 마칠 때마다 발동되므로, 훅이 "아직 완료되지 않았다"고 판단하면 무한 루프에 빠진다.

**반드시 `stop_hook_active` 필드를 확인하는 가드를 넣어야 한다:**

```bash
if [ "$(echo "$INPUT" | jq -r '.stop_hook_active')" = "true" ]; then
  exit 0
fi
```

### 셸 프로필 오염

훅이 비대화형 셸에서 실행될 때, `.zshrc`나 `.bashrc`의 `echo` 문이 JSON 출력을 오염시킬 수 있다. 이는 디버깅하기 까다로운 문제다. 프로필의 모든 출력 문을 `[[ $- == *i* ]]` 가드로 감싸는 것이 좋다.

### 타임아웃 설계

- `command` 훅: 기본 10분. 포맷팅이나 린트는 충분하지만, 대규모 빌드에는 부족할 수 있다
- `agent` 훅: 기본 60초, 최대 50턴. 테스트 스위트가 큰 프로젝트에서는 `timeout` 필드로 조정 필요
- 훅이 타임아웃되면 동작이 그대로 진행되므로, 타임아웃 시 안전하게 실패하는 설계가 중요

### 병렬 실행의 함의

매칭되는 모든 훅은 **병렬로 실행**된다. 이는 성능에 유리하지만, 훅 간 의존성이 있으면 문제가 된다. 예를 들어 "파일 포맷팅 후 린트 실행"은 두 개의 PostToolUse 훅으로 분리하면 순서가 보장되지 않는다. 이 경우 하나의 스크립트 안에서 순차적으로 실행해야 한다.

---

## 5. 권장 도입 순서

훅 시스템을 처음 도입한다면 다음 순서를 권장한다:

1. **알림 훅** (Notification): 가장 안전하고 즉시 생산성 향상. Claude가 입력 대기 중일 때 알림
2. **자동 포맷팅** (PostToolUse + command): Prettier/ESLint 자동 실행으로 코드 스타일 일관성 유지
3. **파일 보호** (PreToolUse + command): `.env` 등 민감 파일 편집 차단
4. **컨텍스트 재주입** (SessionStart + compact): 장시간 세션의 컨텍스트 유실 방지
5. **완료 검증** (Stop + agent): 테스트 통과 확인 등 고급 검증

각 단계를 충분히 운용한 후 다음 단계로 넘어가는 것이 안전하다. 특히 `Stop` 훅의 `agent` 타입은 무한 루프 위험이 있으므로 마지막에 도입하고, 반드시 `stop_hook_active` 가드를 포함해야 한다.

---

## 6. 핵심 인사이트

### "결정론적 제어"의 의미

LLM 기반 도구의 근본적 한계는 비결정성이다. 같은 프롬프트에 다른 결과가 나올 수 있다. 훅은 이 문제를 정면으로 해결한다. "Prettier를 실행해줘"라고 프롬프트에 쓰는 대신, PostToolUse 훅으로 **반드시 실행되도록 보장**한다.

이는 단순한 편의 기능이 아니라, **LLM 도구를 프로덕션 워크플로우에 안전하게 통합하기 위한 아키텍처적 결정**이다.

### 훅 = AI와 기존 도구 사이의 접착제

훅의 진정한 가치는 Claude Code를 기존 개발 도구 생태계와 연결하는 데 있다:
- CI/CD 파이프라인과 연동
- 기존 린터/포맷터와 통합
- 모니터링/로깅 시스템과 연결
- 팀 컨벤션의 기계적 강제

Claude Code를 독립적으로 사용하는 것이 아니라, **기존 워크플로우의 일부로 자연스럽게 통합**하는 것이 훅의 설계 의도다.

### prompt/agent 훅의 잠재력

`command` 훅이 규칙 기반이라면, `prompt`와 `agent` 훅은 **판단 기반 자동화**를 가능하게 한다. 이는 전통적인 CI/CD에서는 불가능했던 영역이다:

- "이 코드 변경이 기존 API 계약을 위반하는가?" (prompt 훅)
- "변경된 파일과 관련된 테스트가 모두 통과하는가?" (agent 훅)
- "커밋 메시지가 컨벤셔널 커밋 형식을 따르는가?" (prompt 훅)

이런 판단은 정규식이나 간단한 스크립트로는 구현하기 어렵지만, LLM 기반 훅으로는 자연스럽게 처리할 수 있다.
