# Claude Code 스킬 시스템 심층 분석

## 핵심 개념 요약

Claude Code의 스킬 시스템은 `SKILL.md` 파일을 통해 Claude의 동작을 확장하는 메커니즘이다. 기존의 커스텀 슬래시 커맨드(`.claude/commands/`)를 발전시킨 형태로, 보조 파일, 프론트매터 기반 호출 제어, 자동 로딩 등의 기능이 추가되었다.

---

## 아키텍처 분석

### 스킬의 이중 구조

스킬은 **프론트매터**(YAML)와 **콘텐츠**(Markdown) 두 층으로 구성된다.

- **프론트매터**: 스킬의 메타데이터와 동작 방식을 선언적으로 정의한다. 호출 권한, 사용 가능한 도구, 실행 환경(인라인 vs 서브에이전트) 등을 제어한다.
- **콘텐츠**: Claude가 실제로 따르는 지침이다. 프롬프트 엔지니어링의 결과물이 코드처럼 파일로 관리된다.

이 구조의 핵심 장점은 **프롬프트를 코드처럼 버전 관리**할 수 있다는 점이다. Git에 커밋하고, PR로 리뷰하고, 팀 전체에 배포할 수 있다.

### 컨텍스트 로딩 전략

스킬의 컨텍스트 관리는 효율적으로 설계되어 있다:

1. **설명(description)만** 항상 컨텍스트에 로드 → 토큰 절약
2. **전체 내용**은 호출 시에만 로드 → 필요할 때만 비용 발생
3. **보조 파일**은 Claude가 판단하여 필요 시 로드 → 추가 절약

이는 LLM의 컨텍스트 윈도우가 유한한 자원이라는 현실적 제약을 잘 반영한 설계다. 스킬이 많아질수록 이 전략의 중요성이 커진다(기본 15,000자 예산).

### 우선순위 체계

```
엔터프라이즈 > 개인 > 프로젝트 (같은 이름일 때)
플러그인은 네임스페이스로 격리 (plugin-name:skill-name)
```

이 체계는 조직 정책이 개인 설정을 오버라이드할 수 있게 하면서도, 프로젝트별 맞춤이 가능한 유연성을 제공한다.

---

## 실전 활용 인사이트

### 1. 팀 코딩 규칙의 자동화

**문제**: 코딩 컨벤션 문서를 만들어도 팀원들이 일관되게 따르지 않는다.

**해결**: 프로젝트 스킬로 코딩 규칙을 정의하면, Claude가 코드 작성 시 자동으로 규칙을 적용한다.

```yaml
---
name: coding-standards
description: 프로젝트 코딩 규칙. 코드 작성, 리뷰, 리팩토링 시 적용.
user-invocable: false  # 배경 지식이므로 메뉴에 노출 불필요
---

## 에러 처리
- 모든 API 호출에 try-catch 적용
- 사용자 대면 에러 메시지는 한국어로

## 네이밍
- 컴포넌트: PascalCase
- 유틸 함수: camelCase
- 상수: UPPER_SNAKE_CASE
```

**포인트**: `user-invocable: false`로 설정하면 사용자가 직접 호출할 필요 없이 Claude가 관련 작업 시 자동으로 참고한다. 컨벤션 문서가 "살아있는 문서"가 되는 셈이다.

### 2. 반복 작업의 원클릭 자동화

**문제**: 배포, PR 생성, 이슈 수정 같은 반복 작업에 매번 같은 절차를 설명해야 한다.

**해결**: `disable-model-invocation: true`로 수동 트리거 전용 스킬을 만든다.

```yaml
---
name: create-pr
description: 현재 변경사항으로 PR 생성
disable-model-invocation: true  # 실수로 자동 실행 방지
allowed-tools: Bash(git *), Bash(gh *)
---

1. git diff로 변경사항 확인
2. 변경사항 분석하여 PR 제목과 본문 작성
3. gh pr create로 PR 생성
4. PR URL 출력
```

**포인트**: 부작용이 있는 작업(배포, 커밋, 외부 API 호출)은 반드시 `disable-model-invocation: true`로 설정해야 한다. Claude가 "좋아 보인다"는 이유로 프로덕션에 배포하는 상황을 방지할 수 있다.

### 3. 동적 컨텍스트로 실시간 정보 주입

**문제**: Claude에게 현재 프로젝트 상태(Git 상태, 환경 변수, 실행 중인 서비스 등)를 매번 알려줘야 한다.

**해결**: `!`command`` 구문으로 셸 명령 결과를 자동 주입한다.

```yaml
---
name: debug-helper
description: 현재 환경 정보와 함께 디버깅 지원
---

## 현재 환경
- Git 브랜치: !`git branch --show-current`
- 최근 커밋: !`git log --oneline -5`
- Node 버전: !`node -v`
- 실행 중인 서비스: !`docker ps --format "table {{.Names}}\t{{.Status}}"`

이 정보를 바탕으로 디버깅을 도와주세요.
```

**포인트**: 동적 컨텍스트 주입은 전처리 단계에서 실행된다. Claude가 보는 것은 명령어가 아니라 그 결과값이다. 이를 통해 항상 최신 상태를 기반으로 작업할 수 있다.

### 4. 서브에이전트를 활용한 격리 실행

**문제**: 코드 분석이나 리서치를 할 때, 메인 대화 컨텍스트가 오염되거나 과도하게 소비된다.

**해결**: `context: fork`로 격리된 서브에이전트에서 실행하고 결과만 받는다.

```yaml
---
name: security-audit
description: 코드베이스 보안 감사 수행
context: fork
agent: Explore  # 읽기 전용 에이전트 사용
---

보안 관점에서 코드베이스를 분석하세요:
1. 하드코딩된 비밀값 검색
2. SQL 인젝션 취약점 확인
3. XSS 가능성 점검
4. 인증/인가 로직 검토
5. 발견사항을 심각도별로 정리
```

**포인트**: `agent: Explore`를 사용하면 읽기 전용 도구만 사용하므로 코드를 실수로 수정할 위험이 없다. 보안 감사처럼 분석만 필요한 경우에 적합하다.

### 5. 모노레포에서의 패키지별 스킬

**문제**: 모노레포에서 프론트엔드와 백엔드의 규칙이 다르다.

**해결**: 중첩 디렉토리의 자동 검색 기능을 활용한다.

```
monorepo/
├── .claude/skills/           # 공통 스킬
│   └── git-conventions/
├── packages/
│   ├── frontend/
│   │   └── .claude/skills/   # 프론트엔드 전용 스킬
│   │       └── react-patterns/
│   └── backend/
│       └── .claude/skills/   # 백엔드 전용 스킬
│           └── api-design/
```

**포인트**: Claude Code는 현재 작업 중인 파일의 경로를 기준으로 중첩된 `.claude/skills/`를 자동 탐색한다. 프론트엔드 파일을 편집 중이면 프론트엔드 스킬이, 백엔드 파일을 편집 중이면 백엔드 스킬이 자동으로 활성화된다.

### 6. 시각화 스크립트 번들링

**문제**: 코드 분석 결과를 텍스트로만 보면 직관적이지 않다.

**해결**: Python/JS 스크립트를 스킬에 번들링하여 인터랙티브 HTML 출력을 생성한다.

이 패턴의 확장 가능성:
- **의존성 그래프**: 패키지 간 관계를 시각화
- **테스트 커버리지 맵**: 커버되지 않은 코드 영역을 히트맵으로 표시
- **API 문서 생성**: 코드에서 자동으로 API 문서 생성
- **데이터베이스 ERD**: 스키마에서 ERD 자동 생성
- **성능 프로파일링 대시보드**: 벤치마크 결과를 차트로 시각화

**포인트**: 스킬에 스크립트를 번들링하면 Claude는 오케스트레이터 역할만 하고, 실제 무거운 작업은 스크립트가 수행한다. 이는 Claude의 강점(맥락 이해, 판단)과 전통적 프로그래밍의 강점(정확한 계산, 파일 I/O)을 결합하는 아키텍처다.

---

## 권한과 보안 모델

### 세 겹의 보안 레이어

1. **스킬 레벨**: `disable-model-invocation`, `user-invocable`, `allowed-tools`
2. **권한 레벨**: `/permissions`에서 `Skill(name)` 규칙으로 세밀 제어
3. **조직 레벨**: 엔터프라이즈 관리 설정으로 전사 정책 강제

### 실전 보안 가이드라인

| 스킬 유형 | 권장 설정 | 이유 |
|:---------|:---------|:-----|
| 배포/릴리스 | `disable-model-invocation: true` | 의도치 않은 프로덕션 변경 방지 |
| 코딩 컨벤션 | `user-invocable: false` | 배경 지식으로만 활용 |
| 코드 리뷰 | 기본값 (둘 다 가능) | 사용자 요청 시 또는 관련 시 자동 실행 |
| 외부 API 호출 | `disable-model-invocation: true` + `allowed-tools` 제한 | 비용/부작용 통제 |

---

## 스킬 설계 베스트 프랙티스

### 1. description을 정밀하게 작성하라

Claude가 스킬을 자동으로 호출할지 결정하는 핵심 요소다. 너무 광범위하면 원치 않는 호출이 발생하고, 너무 좁으면 필요할 때 호출되지 않는다.

```yaml
# 나쁜 예: 너무 광범위
description: 코드 관련 작업을 도와줍니다

# 좋은 예: 구체적인 트리거 조건 명시
description: React 컴포넌트의 성능을 최적화합니다. useMemo, useCallback, React.memo 관련 질문이나 렌더링 성능 이슈를 다룰 때 사용합니다.
```

### 2. SKILL.md는 500줄 이하로 유지하라

상세한 참조 자료는 별도 파일로 분리하고, SKILL.md에서 참조하는 방식을 사용한다. 이는 컨텍스트 토큰을 절약하고 스킬의 핵심 로직을 명확하게 유지하는 데 도움이 된다.

### 3. 인수 치환을 적극 활용하라

`$ARGUMENTS`, `$0`, `$1` 등을 사용하면 하나의 스킬로 다양한 시나리오를 처리할 수 있다. 범용성 있는 스킬을 만드는 핵심 기법이다.

### 4. context: fork의 사용 기준

- **사용해야 할 때**: 독립적인 분석/리서치 작업, 메인 대화 컨텍스트를 오염시키고 싶지 않을 때
- **사용하지 말아야 할 때**: 대화 맥락이 필요한 참조 콘텐츠, 명시적 작업 없이 가이드라인만 제공하는 경우

### 5. Agent Skills 오픈 표준을 고려하라

Claude Code 스킬은 [Agent Skills](https://agentskills.io) 오픈 표준을 따른다. 이를 의식하면 다른 AI 도구로의 이식성을 확보할 수 있다. Claude Code 전용 기능(`context: fork`, `agent` 등)은 표준의 확장이므로, 핵심 로직은 표준 범위 내에서 작성하고 Claude Code 전용 기능은 부가적으로 활용하는 것이 좋다.

---

## 결론

Claude Code의 스킬 시스템은 단순한 프롬프트 템플릿을 넘어, **AI 에이전트의 행동을 코드로 관리하는 인프라**다. 핵심 가치는 다음 세 가지로 요약된다:

1. **프롬프트의 코드화**: 프롬프트를 파일로 관리하여 버전 관리, 코드 리뷰, 팀 공유가 가능해진다.
2. **선언적 제어**: YAML 프론트매터로 호출 권한, 실행 환경, 도구 접근을 선언적으로 정의한다.
3. **조합 가능한 아키텍처**: 스킬, 서브에이전트, 훅, 플러그인이 결합되어 복잡한 워크플로를 구성할 수 있다.

이 시스템을 효과적으로 활용하면, 반복적인 작업을 자동화하고, 팀의 코딩 품질을 일관되게 유지하며, Claude를 프로젝트에 특화된 전문가로 만들 수 있다.
