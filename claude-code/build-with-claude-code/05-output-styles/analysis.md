# Claude Code Skills 심층 분석 및 활용 인사이트

## 1. 핵심 개념 정리

### Skills란 무엇인가?

Skills는 Claude Code의 기능을 확장하는 **모듈형 지시사항 시스템**이다. `SKILL.md` 파일에 지시사항을 작성하면 Claude가 이를 도구 모음에 추가하여, 상황에 맞게 자동으로 활용하거나 슬래시 커맨드(`/skill-name`)로 직접 호출할 수 있다.

기존의 `.claude/commands/`를 발전시킨 형태로, 다음과 같은 추가 기능을 제공한다:
- 보조 파일 디렉토리 구조
- 프론트매터를 통한 호출 권한 제어
- Claude의 자동 로드 기능
- 서브에이전트에서의 격리 실행
- 동적 컨텍스트 주입

### 아키텍처 구조

```
스킬 시스템
├── 프론트매터 (YAML)     → 동작 설정 (언제, 누가, 어떻게)
├── 마크다운 콘텐츠        → 실제 지시사항 (무엇을)
├── 보조 파일              → 참조 문서, 템플릿, 스크립트
└── 문자열 치환            → 동적 값 주입 ($ARGUMENTS, $N 등)
```

---

## 2. 스킬의 두 가지 유형과 설계 전략

### 참조 콘텐츠 (Reference Content)
- **목적**: Claude에게 지식을 추가하여 현재 작업에 적용
- **실행 방식**: 인라인 (대화 컨텍스트와 함께)
- **예시**: API 컨벤션, 코딩 스타일 가이드, 도메인 지식

### 태스크 콘텐츠 (Task Content)
- **목적**: 특정 작업의 단계별 지시사항
- **실행 방식**: 주로 수동 호출 또는 서브에이전트에서 격리 실행
- **예시**: 배포 프로세스, 코드 생성 워크플로, 이슈 수정 절차

**설계 인사이트**: 스킬을 만들 때 가장 먼저 결정할 것은 "이것이 지식인가, 행동인가?"이다. 이 구분이 `disable-model-invocation`, `context: fork` 등의 설정을 결정짓는다.

---

## 3. 호출 제어 매트릭스 분석

| 설정 | 사용자 | Claude | 적합한 시나리오 |
|:---|:---|:---|:---|
| 기본값 | O | O | 범용 스킬 (코드 설명, 리팩토링 가이드) |
| `disable-model-invocation: true` | O | X | 부작용이 있는 작업 (배포, 커밋, 외부 API 호출) |
| `user-invocable: false` | X | O | 배경 지식 (레거시 시스템 컨텍스트, 도메인 규칙) |

**핵심 인사이트**: `disable-model-invocation`은 **안전 장치**다. Claude가 "코드가 준비된 것 같으니 배포하겠습니다"라고 자의적으로 판단하는 것을 방지한다. 부작용이 있는 모든 스킬에는 이 설정을 기본으로 적용하는 것이 좋다.

---

## 4. 컨텍스트 관리 전략

### 레이지 로딩 아키텍처
- 스킬 **description만** 항상 컨텍스트에 로드
- **전체 콘텐츠**는 호출 시에만 로드
- 보조 파일은 Claude가 필요할 때만 읽음

이는 LLM의 컨텍스트 윈도우를 효율적으로 사용하기 위한 설계다.

### 실용적 가이드라인
- `SKILL.md`는 500줄 이하로 유지
- 상세 참조 문서는 별도 파일로 분리
- description에 핵심 키워드를 반드시 포함 (자동 트리거의 핵심)
- 스킬이 많으면 `SLASH_COMMAND_TOOL_CHAR_BUDGET` 환경 변수로 예산 조정

---

## 5. 서브에이전트 실행 (`context: fork`) 심층 분석

`context: fork`는 스킬을 **격리된 서브에이전트**에서 실행한다. 이는 다음과 같은 의미를 갖는다:

1. **대화 기록에 접근 불가** → 스킬 콘텐츠 자체가 완전한 프롬프트여야 함
2. **에이전트 유형 선택 가능** → `Explore`, `Plan`, `general-purpose`, 커스텀 에이전트
3. **결과만 반환** → 메인 대화에 요약된 결과가 돌아옴

### 언제 `context: fork`를 사용해야 하는가?
- 무거운 탐색/분석 작업 (컨텍스트 오염 방지)
- 특정 도구 세트만 필요한 작업 (allowed-tools와 조합)
- 메인 대화 흐름과 독립적인 작업

### 주의사항
참조 콘텐츠(가이드라인)만 있고 구체적 태스크가 없는 스킬에 `context: fork`를 사용하면, 서브에이전트가 무엇을 해야 할지 몰라 의미 없는 결과를 반환한다. **반드시 명시적 지시사항이 포함된 스킬에만 사용**해야 한다.

---

## 6. 동적 컨텍스트 주입의 활용

`!`command`` 문법은 스킬의 가장 강력한 기능 중 하나다. 셸 커맨드의 출력을 스킬 콘텐츠에 사전 주입하여, Claude가 **실시간 데이터를 기반으로 작업**할 수 있게 한다.

### 활용 시나리오
```
!`git log --oneline -10`     → 최근 커밋 기반 작업
!`gh pr diff`                → PR 리뷰 자동화
!`cat package.json`          → 프로젝트 설정 기반 판단
!`docker ps`                 → 현재 인프라 상태 기반 작업
!`curl -s api/health`        → 서비스 상태 확인 후 작업
```

**핵심 인사이트**: 이것은 **전처리**다. Claude가 커맨드를 실행하는 것이 아니라, 스킬이 로드되기 전에 시스템이 실행한다. 따라서 실행 시간이 긴 커맨드나 인터랙티브 커맨드는 피해야 한다.

---

## 7. 실전 활용 패턴

### 패턴 1: 팀 코딩 컨벤션 강제

```yaml
---
name: team-conventions
description: 팀의 코딩 컨벤션과 패턴
user-invocable: false
---
```
- `user-invocable: false`로 설정하여 Claude가 자동으로 참조
- 프로젝트 레벨(`.claude/skills/`)에 배치하여 팀 전체 공유
- 버전 관리에 커밋하여 코드와 함께 진화

### 패턴 2: 안전한 배포 파이프라인

```yaml
---
name: deploy
disable-model-invocation: true
context: fork
allowed-tools: Bash(deploy.sh *)
---
```
- 수동 호출만 가능 (`disable-model-invocation: true`)
- 격리된 환경에서 실행 (`context: fork`)
- 허용된 도구만 사용 가능 (`allowed-tools`)

### 패턴 3: 코드 리뷰 자동화

```yaml
---
name: review
context: fork
agent: Explore
---
!`git diff --cached`를 분석하고 다음 관점에서 리뷰:
1. 보안 취약점
2. 성능 이슈
3. 코딩 컨벤션 준수
```
- 동적 컨텍스트 주입으로 현재 변경사항 자동 수집
- Explore 에이전트로 코드베이스 전체 맥락에서 리뷰

### 패턴 4: 시각적 출력 생성

스킬에 Python/Node.js 스크립트를 번들링하여 인터랙티브 HTML을 생성하는 패턴이다. 활용 가능한 영역:
- 코드베이스 구조 시각화
- 의존성 그래프
- 테스트 커버리지 리포트
- API 문서 자동 생성
- 데이터베이스 스키마 다이어그램

### 패턴 5: 모노레포 전용 스킬

```
packages/
├── frontend/.claude/skills/   → 프론트엔드 전용 스킬
├── backend/.claude/skills/    → 백엔드 전용 스킬
└── shared/.claude/skills/     → 공유 스킬
```
중첩 디렉토리 자동 발견 기능을 활용하여, 각 패키지에 맞는 스킬을 자동으로 적용한다.

---

## 8. 스킬 우선순위와 충돌 해결

```
엔터프라이즈 (최고 우선순위)
    ↓
개인 (~/.claude/skills/)
    ↓
프로젝트 (.claude/skills/)
    ↓
플러그인 (네임스페이스로 격리)
```

- 같은 이름의 스킬은 상위 레벨이 우선
- 플러그인은 `plugin-name:skill-name` 네임스페이스로 충돌 방지
- 기존 `.claude/commands/`와 같은 이름이면 스킬이 우선

**실용적 조언**: 개인 스킬과 프로젝트 스킬의 이름이 충돌하지 않도록, 프로젝트 스킬에는 프로젝트 고유 접두사를 사용하는 것이 좋다.

---

## 9. 권한 관리 모범 사례

### 최소 권한 원칙 적용
```yaml
allowed-tools: Read, Grep, Glob    # 읽기 전용
allowed-tools: Bash(python *)       # 특정 커맨드만
allowed-tools: Bash(gh *)           # GitHub CLI만
```

### 권한 규칙을 통한 세밀한 제어
```
Skill(deploy *)    # deploy 스킬 거부 (deny 규칙에 추가)
Skill(commit)      # commit 스킬만 허용 (allow 규칙에 추가)
```

---

## 10. 핵심 인사이트 요약

1. **스킬 = 재사용 가능한 프롬프트 엔지니어링**: 잘 만든 스킬은 매번 같은 지시를 반복하지 않아도 되게 한다.

2. **description이 스킬의 성패를 결정**: Claude의 자동 트리거는 description의 키워드 매칭에 의존한다. 사용자가 자연스럽게 말할 표현을 포함해야 한다.

3. **안전 우선 설계**: 부작용이 있는 스킬에는 반드시 `disable-model-invocation: true`를 설정한다.

4. **컨텍스트 효율성**: 스킬의 레이지 로딩 아키텍처를 이해하고, SKILL.md는 간결하게, 상세 내용은 보조 파일로 분리한다.

5. **팀 협업 도구로 활용**: 프로젝트 스킬을 버전 관리에 커밋하면, 코딩 컨벤션과 워크플로를 코드와 함께 공유하고 진화시킬 수 있다.

6. **동적 컨텍스트 주입은 실시간 데이터 기반 작업의 핵심**: `!`command`` 문법으로 현재 상태(git diff, PR 정보, 서비스 상태 등)를 스킬에 주입할 수 있다.

7. **Agent Skills 오픈 표준 호환**: Claude Code에서 만든 스킬이 다른 AI 도구에서도 작동할 수 있어, 특정 도구에 대한 종속성을 줄인다.

8. **점진적 도입 가능**: 기존 `.claude/commands/` 파일이 그대로 작동하므로, 기존 사용자는 자연스럽게 스킬 시스템으로 전환할 수 있다.
