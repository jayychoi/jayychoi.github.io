# Claude Code 커스텀 서브에이전트 심층 분석

## 1. 핵심 개념 요약

Claude Code의 서브에이전트는 **독립된 컨텍스트 윈도우에서 실행되는 특화된 AI 어시스턴트**다. 각 서브에이전트는 자체 시스템 프롬프트, 도구 접근 권한, 권한 모드를 가지며, 메인 대화와 격리된 상태에서 작업을 수행하고 결과만 반환한다.

핵심 설계 원칙은 **관심사의 분리(Separation of Concerns)**다. 서브에이전트는 마이크로서비스 아키텍처에서 각 서비스가 단일 책임을 갖는 것처럼, 각각 하나의 특정 역할에 집중한다.

## 2. 아키텍처 분석

### 2.1 컨텍스트 격리 모델

서브에이전트의 가장 중요한 특성은 **컨텍스트 격리**다.

```
메인 대화 (컨텍스트 윈도우 A)
  ├── 서브에이전트 1 (컨텍스트 윈도우 B) → 결과 요약만 반환
  ├── 서브에이전트 2 (컨텍스트 윈도우 C) → 결과 요약만 반환
  └── 서브에이전트 3 (컨텍스트 윈도우 D) → 결과 요약만 반환
```

이 설계가 주는 이점:
- **메인 대화의 컨텍스트 효율성**: 테스트 실행 결과, 로그 분석 등 대량의 출력이 메인 컨텍스트를 오염시키지 않는다
- **독립적 압축**: 각 서브에이전트는 자체 압축 사이클을 가진다. 메인 대화가 압축되어도 서브에이전트 트랜스크립트는 영향 없다
- **재개 가능성**: 서브에이전트 ID를 통해 이전 컨텍스트를 완전히 보존한 채 재개할 수 있다

### 2.2 위임 메커니즘

Claude는 `description` 필드를 기반으로 자동 위임을 결정한다. 이는 사실상 **자연어 기반의 라우팅 시스템**이다.

```
사용자 요청 → Claude가 description 매칭 → 적절한 서브에이전트에 위임 → 결과 수신
```

이 설계의 함의:
- `description`이 곧 라우팅 규칙이다. 모호한 설명은 잘못된 위임으로 이어진다
- "use proactively"와 같은 트리거 문구로 사전 위임을 유도할 수 있다
- 사용자가 명시적으로 서브에이전트를 지정할 수도 있어, 자동과 수동 위임이 공존한다

### 2.3 제약 사항

- **서브에이전트는 서브에이전트를 생성할 수 없다** (단일 깊이 제한)
- **백그라운드 서브에이전트는 MCP 도구를 사용할 수 없다**
- **백그라운드 서브에이전트는 사용자에게 질문할 수 없다** (AskUserQuestion 실패)
- 서브에이전트는 전체 Claude Code 시스템 프롬프트가 아닌, 자체 시스템 프롬프트와 기본 환경 정보만 받는다

## 3. 실전 활용 전략

### 3.1 개발 워크플로우 자동화

#### 코드 리뷰 파이프라인

프로젝트에 `.claude/agents/` 디렉토리를 만들어 팀 전체가 사용하는 리뷰 에이전트를 버전 관리할 수 있다.

```yaml
---
name: pr-reviewer
description: Review pull request changes. Use proactively after code changes.
tools: Read, Grep, Glob, Bash
model: sonnet
permissionMode: plan
---
```

`permissionMode: plan`으로 설정하면 읽기 전용으로 동작하여 안전하게 코드를 분석한다. 팀의 코딩 컨벤션, 보안 체크리스트 등을 시스템 프롬프트에 포함시키면 일관된 리뷰 기준을 유지할 수 있다.

#### 테스트 실행 격리

```
테스트 실행 → 대량의 출력 (수백~수천 라인)
  └── 서브에이전트에 위임 → 실패한 테스트 + 에러 메시지만 요약 반환
```

테스트 결과 전체가 메인 컨텍스트에 들어가면 이후 대화의 품질이 저하된다. 서브에이전트를 통해 "실패한 테스트만 보고"하도록 하면 컨텍스트를 효율적으로 사용할 수 있다.

### 3.2 보안 강화 패턴

#### PreToolUse 훅을 활용한 가드레일

`tools` 필드만으로는 "Bash는 허용하되 특정 명령만 차단"하는 세밀한 제어가 불가능하다. `PreToolUse` 훅이 이 갭을 채운다.

```
도구 사용 요청 → PreToolUse 훅 실행 → 검증 스크립트
  ├── exit 0: 허용
  └── exit 2: 차단 (stderr 메시지가 Claude에 피드백)
```

실전 활용 예시:
- **DB 서브에이전트**: SELECT만 허용, INSERT/UPDATE/DELETE 차단
- **배포 서브에이전트**: 특정 브랜치에서만 배포 허용
- **파일 접근 제한**: 특정 디렉토리 외부의 파일 접근 차단

이 패턴은 **Defense in Depth** 원칙을 구현한다. `tools`로 1차 제한, `disallowedTools`로 2차 제한, `PreToolUse` 훅으로 3차 세밀한 제어를 적용한다.

#### 권한 모드의 전략적 사용

| 시나리오 | 권장 모드 | 이유 |
|---------|----------|------|
| 코드 리뷰 | `plan` | 수정 없이 분석만 |
| 자동 포매팅 | `acceptEdits` | 편집은 허용, 기타 위험 작업 차단 |
| CI/CD 파이프라인 | `dontAsk` | 자동 실행 시 프롬프트 불가 |
| 개발 테스트 | `bypassPermissions` | 빠른 반복 (주의 필요) |

### 3.3 모델 라우팅을 통한 비용 최적화

서브에이전트별로 모델을 다르게 설정할 수 있다는 점은 **비용과 성능의 트레이드오프를 세밀하게 제어**할 수 있음을 의미한다.

| 작업 유형 | 권장 모델 | 근거 |
|----------|----------|------|
| 코드베이스 탐색/검색 | `haiku` | 빠르고 저렴, 단순 검색에 충분 |
| 코드 리뷰/분석 | `sonnet` | 능력과 속도의 균형 |
| 복잡한 아키텍처 설계 | `opus` 또는 `inherit` | 깊은 추론 필요 |
| 단순 파일 읽기/린팅 | `haiku` | 비용 절감 효과 극대화 |

내장 Explore 에이전트가 Haiku를 사용하는 것은 이 전략의 좋은 예시다. 코드베이스 탐색은 빠르고 저렴한 모델로 충분하다.

### 3.4 팀 협업 패턴

#### 프로젝트 수준 서브에이전트 공유

`.claude/agents/`에 서브에이전트를 정의하고 Git에 커밋하면:
- 팀 전체가 동일한 리뷰 기준, 디버깅 프로세스를 공유
- 서브에이전트 설정 변경도 코드 리뷰를 거침
- 프로젝트별 도메인 지식이 서브에이전트에 축적

#### 플러그인을 통한 조직 단위 배포

여러 프로젝트에 걸쳐 동일한 서브에이전트를 배포해야 한다면 플러그인 시스템을 활용한다. 보안 정책, 코딩 컨벤션 등 조직 수준의 규칙을 서브에이전트로 패키지화하여 배포할 수 있다.

### 3.5 스킬과 서브에이전트의 결합

`skills` 필드를 통해 서브에이전트에 도메인 지식을 사전 주입할 수 있다. 이는 **컨텍스트 프리로딩**이다.

```yaml
---
name: api-developer
skills:
  - api-conventions      # 팀의 API 설계 규칙
  - error-handling-patterns  # 에러 처리 패턴
---
```

스킬의 전체 내용이 서브에이전트 시작 시 주입되므로, 서브에이전트가 별도로 스킬을 탐색할 필요가 없다. 이를 통해:
- 서브에이전트의 첫 응답부터 팀 컨벤션을 따른다
- 매번 컨벤션 문서를 찾는 오버헤드가 제거된다
- 일관된 코드 생성이 보장된다

## 4. 서브에이전트 vs 스킬: 언제 무엇을 쓸까

| 기준 | 서브에이전트 | 스킬 |
|------|------------|------|
| 컨텍스트 | 격리된 별도 윈도우 | 메인 대화 내 |
| 도구 제한 | 독립적으로 제어 가능 | 메인 대화와 동일 |
| 모델 | 별도 지정 가능 | 메인 대화와 동일 |
| 적합한 작업 | 자체 완결적, 대량 출력 | 대화 흐름 내 재사용 로직 |
| 중첩 | 불가 (단일 깊이) | 가능 |

## 5. 안티패턴과 주의사항

### 피해야 할 것

1. **과도한 서브에이전트 사용**: 간단한 작업에도 서브에이전트를 쓰면 오히려 지연 증가. 서브에이전트는 처음부터 컨텍스트를 구축해야 한다
2. **모호한 description**: Claude가 잘못된 서브에이전트에 위임하거나, 위임 자체를 하지 않을 수 있다
3. **과다한 병렬 서브에이전트**: 각 서브에이전트의 결과가 메인 컨텍스트로 반환되므로, 너무 많은 서브에이전트를 동시에 실행하면 컨텍스트가 빠르게 소진된다
4. **bypassPermissions 남용**: 특히 프로젝트 수준 서브에이전트에서 사용하면 팀원 모두에게 적용되어 보안 위험이 커진다
5. **너무 넓은 도구 접근**: 최소 권한 원칙을 따라야 한다. 리뷰 에이전트에 Write/Edit 도구가 필요한지 재고

### 효과적인 패턴

1. **단일 책임 원칙**: 하나의 서브에이전트는 하나의 역할만
2. **명확한 description**: "use proactively after..." 같은 트리거 조건 명시
3. **적절한 모델 선택**: 작업 복잡도에 맞는 모델로 비용 최적화
4. **훅을 통한 세밀한 제어**: tools/disallowedTools로 부족할 때 PreToolUse 훅 활용
5. **체이닝 패턴**: 분석 → 수정 → 검증 같은 파이프라인은 여러 서브에이전트를 순차 실행

## 6. 결론

Claude Code의 서브에이전트 시스템은 단순한 태스크 위임을 넘어, **AI 어시스턴트의 아키텍처를 소프트웨어 엔지니어링 원칙으로 설계할 수 있는 프레임워크**다. 마이크로서비스의 관심사 분리, 최소 권한 원칙, Defense in Depth, 파이프라인 패턴 등 검증된 소프트웨어 엔지니어링 원칙들이 서브에이전트 설계에 직접 적용된다.

핵심은 **적재적소**다. 모든 작업에 서브에이전트를 쓰는 것이 아니라, 컨텍스트 격리가 필요하거나, 도구 제한이 필요하거나, 비용 최적화가 필요한 지점에서 전략적으로 활용할 때 최대의 효과를 얻을 수 있다.
